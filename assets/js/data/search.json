[ { "title": "graphcodebert+pairwise ensemble 0.8462", "url": "/posts/ai4code-cb-pw-ensemble/", "categories": "NLP, KAGGLE, AI4CODE", "tags": "nlp, kaggle, graphcodebert, pairwise, ensemble", "date": "2022-09-10 11:15:04 +0900", "snippet": "codebert에 model.from_pretrained에서, 단순히 codebert를 graphcodebert로 바꾸고 pairwise의 결과와의 단순 가중치 앙상블Rank Ensemble캐글 리더보드에 저 비율을 쓰더라# Reading the submissionsdf_1 = pd.read_csv('submission1.csv')df_2 = pd.read_csv('submission2.csv')# Averaging the indices and sorting the resulting submission by the aggregated ensembled indicesnew_samples = []for sample_idx in range(len(df_1)): # {'0a226b6a': 0, ...} sample_1 = {k: v for v, k in enumerate(df_1.iloc[sample_idx]['cell_order'].split(' '))} sample_2 = {k: v for v, k in enumerate(df_2.iloc[sample_idx]['cell_order'].split(' '))} for key in sample_1: sample_1[key] = ((sample_1[key] * 0.748) + (sample_2[key] * 0.252)) new_samples.append(' '.join([i[0] for i in list(sorted(sample_1.items(), key = lambda x: x[1]))]))df_1['cell_order'] = new_samplesResultpublic: 0.8462private: 0.8410 (holy shit…)" }, { "title": "codebert(base) - [1md+20code]’s CLS ranking 0.8412", "url": "/posts/ai4code-codebert/", "categories": "NLP, KAGGLE, AI4CODE", "tags": "nlp, kaggle, codebert", "date": "2022-09-10 11:15:03 +0900", "snippet": "Preprocess기본적인 데이터 추출은 baseline의 그것과 같다class Preprocessor: def __init__(self, **args): self.__dict__.update(args) self.data_dir = Path(self.input_path) def read_notebook(self, path): return ( pd.read_json(path, dtype={'cell_type': 'category', 'source': 'str'}) .assign(id=path.stem) .rename_axis('cell_id') ) def get_ranks(self, base, derived): return [base.index(d) for d in derived] def run(self, mode='train', nvalid=0.1): if os.path.exists(self.train_path) and os.path.exists(self.val_path): print('train_df, val_df are already exits') train_df = pd.read_csv(self.train_path) val_df = pd.read_csv(self.val_path) train_df_mark = pd.read_csv(self.train_mark_path) val_df_mark = pd.read_csv(self.val_mark_path) return train_df, val_df, train_df_mark, val_df_mark paths = list((self.data_dir / mode).glob('*.json')) notebooks = [self.read_notebook(path) for path in tqdm(paths, desc=f'{mode} NBs')] df = (pd.concat(notebooks) .set_index('id', append=True) .swaplevel() .sort_index(level='id', sort_remaining=False)) df_orders = pd.read_csv( self.data_dir / 'train_orders.csv', index_col='id', squeeze=True).str.split() df_orders_ = df_orders.to_frame().join( df.reset_index('cell_id').groupby('id')['cell_id'].apply(list), how='right' ) ranks = {} for id_, cell_order, cell_id in df_orders_.itertuples(): ranks[id_] = {'cell_id': cell_id, 'rank': self.get_ranks(cell_order, cell_id)} df_ranks = ( pd.DataFrame .from_dict(ranks, orient='index') .rename_axis('id') .apply(pd.Series.explode) .set_index('cell_id', append=True) ) df_ancestors = pd.read_csv( self.data_dir / 'train_ancestors.csv', index_col='id') df = df.reset_index().merge( df_ranks, on=['id', 'cell_id']).merge(df_ancestors, on=['id']) df['pct_rank'] = df['rank'] / \\ df.groupby('id')['cell_id'].transform('count') splitter = GroupShuffleSplit( n_splits=1, test_size=nvalid, random_state=0) train_ind, val_ind = next(splitter.split(df, groups=df['ancestor_id'])) train_df = df.loc[train_ind].reset_index(drop=True) val_df = df.loc[val_ind].reset_index(drop=True) train_df_mark = train_df[train_df['cell_type'] == 'markdown'].reset_index(drop=True) val_df_mark = val_df[val_df['cell_type'] == 'markdown'].reset_index(drop=True) train_df_mark.to_csv(self.train_mark_path + f'_fold{i}') val_df_mark.to_csv(self.val_mark_path + f'_fold{i}') train_df.to_csv(self.train_path + f'_fold{i}') val_df.to_csv(self.val_path + f'_fold{i}') return train_df, val_df, train_df_mark, val_df_mark여기에 추가적으로 노트북 당 최대 20개의 코드셀과 코드 셀 개수, 마크 다운 셀의 개수를 추출class _20CodeCellPreprocessor(Preprocessor): def __init__(self, **args): self.__dict__.update(args) super(_20CodeCellPreprocessor, self).__init__(**args) def clean_code(self, cell): return str(cell).replace('\\\\n', '\\n') def sample_cells(self, cells, n=20): cells = [self.clean_code(cell) for cell in cells] if n &gt;= len(cells): # 코드 셀이 20개 이하라면 그냥 반환 return [cell[:200] for cell in cells] else: results = [] step = len(cells) / n # 총 20개의 코드셀이 샘플링 되도록 스텝을 조절 idx = 0 while int(np.round(idx) &lt; len(cells)): results.append(cells[int(np.round(idx))]) idx += step assert cells[0] in results # 첫번쨰 코드셀은 반드시 들어가야 한다? if cells[-1] not in results: # 말전 코드셀은 반드시 들어가야 한다? results[-1] = cells[-1] return results def get_features(self, df): features = dict() df = df.sort_values('rank').reset_index(drop=True) for idx, sub_df in tqdm(df.groupby('id')): features[idx] = dict() total_md = sub_df[sub_df.cell_type == 'markdown'].shape[0] code_sub_df = sub_df[sub_df.cell_type == 'code'] total_code = code_sub_df.shape[0] codes = self.sample_cells(code_sub_df.source.values, 20) features[idx]['total_code'] = total_code features[idx]['total_md'] = total_md features[idx]['codes'] = codes # features = { # 노트북id: { # 'total_code': 코드 셀의 개수, # 'total_md': 마크다운 샐의 개수, # 'codes': [코드셀0, 코드셀1, ... , 코드셀 19] # }, # ... # } return features def run(self): train_df, val_df, train_df_mark, val_df_mark = super().run() if os.path.exists(self.train_features_path) and os.path.exists(self.val_features_path): print('train_fts, val_fts are already exists') train_fts = json.load(open(self.train_features_path)) val_fts = json.load(open(self.val_features_path)) else: train_fts = self.get_features(train_df) val_fts = self.get_features(val_df) json.dump(train_fts, open(self.train_features_path,\"wt\")) json.dump(val_fts, open(self.val_features_path,\"wt\")) return train_df, val_df, train_df_mark, val_df_mark, train_fts, val_ftsDatasetBERT에 입력할 커스텀 데이터셋을 만들어줘야 한다하나의 입력 시퀀스 : [마크다운셀 1개, 코드셀 0, 코드셀 1, … , 코드셀 19]class _20SampleDataset(Dataset): def __init__(self, df, model_name_or_path, total_max_len, md_max_len, fts): super().__init__() self.df = df.reset_index(drop=True) self.md_max_len = md_max_len self.total_max_len = total_max_len self.fts = fts self.tokenizer = AutoTokenizer.from_pretrained(model_name_or_path) def __getitem__(self, index): row = self.df.iloc[index] inputs = self.tokenizer.encode_plus( row.source, None, add_special_tokens=True, max_length=self.md_max_len, padding='max_length', return_token_type_ids=True, truncation=True ) code_inputs = self.tokenizer.batch_encode_plus( [str(x) for x in self.fts[row.id]['codes']], add_special_tokens=True, max_length=23, padding='max_length', truncation=True ) n_md = self.fts[row.id]['total_md'] n_code = self.fts[row.id]['total_code'] if n_md + n_code == 0: fts = torch.FloatTensor([0]) else: fts = torch.FloatTensor([n_md / (n_md + n_code)]) ids = inputs['input_ids'] for x in code_inputs['input_ids']: ids.extend(x[:-1]) ids = ids[:self.total_max_len] if len(ids) != self.total_max_len: ids = ids + [self.tokenizer.pad_token_id, ] * (self.total_max_len - len(ids)) ids = torch.LongTensor(ids) mask = inputs['attention_mask'] for x in code_inputs['attention_mask']: mask.extend(x[:-1]) mask = mask[:self.total_max_len] if len(mask) != self.total_max_len: mask = mask + [self.tokenizer.pad_token_id, ] * (self.total_max_len - len(mask)) mask = torch.LongTensor(mask) assert len(ids) == len(mask) return ids, mask, fts, torch.FloatTensor([row.pct_rank]) def __len__(self): return self.df.shape[0]Model위 입력 시퀀스의 [cls]의 표현 벡터를 추출class _20SampleModel(nn.Module): def __init__(self, model_path): super(_20SampleModel, self).__init__() config = AutoConfig.from_pretrained(model_path) self.model = AutoModel.from_pretrained(model_path) self.dropout1 = nn.Dropout(0.1) self.dropout2 = nn.Dropout(0.2) self.dropout3 = nn.Dropout(0.3) self.dropout4 = nn.Dropout(0.4) self.dropout5 = nn.Dropout(0.5) self.top = nn.Linear(config.hidden_size+1, 1) # for train_fts def forward(self, ids, mask, fts, labels=None): x = self.model(ids, mask)[0] x = torch.cat((x[:, 0, :], fts), 1) # [CLS]만 쓸거임. x1 = self.top(self.dropout1(x)) x2 = self.top(self.dropout2(x)) x3 = self.top(self.dropout3(x)) x4 = self.top(self.dropout4(x)) x5 = self.top(self.dropout5(x)) x = (x1 + x2 + x3 + x4 + x5) / 5 return xTrain훈련 시 필요한 것들 세팅def train_setup(args): model = _20SampleModel(model_path=args.model_name_or_path) param_optimizer = list(model.named_parameters()) no_decay = ['bias', 'LayerNorm.bias', 'LayerNorm.weight'] optimizer_grouped_parameters = [ {'params': [p for n, p in param_optimizer if not any( nd in n for nd in no_decay)], 'weight_decay': 0.01}, {'params': [p for n, p in param_optimizer if any( nd in n for nd in no_decay)], 'weight_decay': 0.0} ] num_train_optimization_steps = args.num_train_steps optimizer = AdamW(optimizer_grouped_parameters, lr=3e-5, correct_bias=False) scheduler = ( CosineAnnealingWarmupRestarts( optimizer=optimizer, first_cycle_steps=num_train_optimization_steps, cycle_mult=1, max_lr=args.max_lr, min_lr=args.min_lr, warmup_steps=num_train_optimization_steps * 0.2, gamma=1., last_epoch=-1 )) # Pytorch scheduler # scheduler = get_linear_schedule_with_warmup( # optimizer=optimizer, # num_warmup_steps=0.05*num_train_optimization_steps, # num_training_steps=num_train_optimization_steps, # ) scaler = torch.cuda.amp.GradScaler() return model, optimizer, scheduler, scalerdef read_data(data): return tuple(d.cuda() for d in data[:-1]), data[-1].cuda()def validate(model, val_loader): model.eval() tbar = tqdm(val_loader, file=sys.stdout, position=0, leave=True) preds = [] labels = [] with torch.no_grad(): for idx, data in enumerate(tbar): inputs, target = read_data(data) with torch.cuda.amp.autocast(): pred = model(*inputs) preds.append(pred.detach().cpu().numpy().ravel()) labels.append(target.detach().cpu().numpy().ravel()) return np.concatenate(labels), np.concatenate(preds)def train(model, train_loader, val_loader, optimizer, scheduler, scaler, val_df, df_orders, args): criterion = torch.nn.L1Loss() for e in range(args.epoch, 100): model.train() tbar = tqdm(train_loader, file=sys.stdout, position=0, leave=True) loss_list = [] preds = [] labels = [] for idx, data in enumerate(tbar): inputs, target = read_data(data) with torch.cuda.amp.autocast(): pred = model(*inputs) loss = criterion(pred, target) scaler.scale(loss).backward() if idx % args.accumulation_steps == 0 or idx == len(tbar) - 1: scaler.step(optimizer) scaler.update() optimizer.zero_grad() scheduler.step() loss_list.append(loss.detach().cpu().item()) preds.append(pred.detach().cpu().numpy().ravel()) labels.append(target.detach().cpu().numpy().ravel()) avg_loss = np.round(np.mean(loss_list), 4) tbar.set_description( f'Epoch {e+1} Loss: {avg_loss} lr: {scheduler.get_lr()}') y_val, y_pred = validate(model, val_loader) val_df['pred'] = val_df.groupby(['id', 'cell_type'])['rank'].rank(pct=True) val_df.loc[val_df['cell_type'] == 'markdown', 'pred'] = y_pred y_dummy = val_df.sort_values('pred').groupby('id')['cell_id'].apply(list) preds_score = kendall_tau(df_orders.loc[y_dummy.index], y_dummy) print(\"Preds score\", preds_score) if not os.path.exists(args.output_path): os.mkdir(args.output_path) torch.save(model.state_dict(), args.output_path + f'/model_epoch_{e}_{preds_score}.bin')Resultpublic score : 0.8412" }, { "title": "distillbert(small) - pairwise 0.8171", "url": "/posts/ai4code-pairwise/", "categories": "NLP, KAGGLE, AI4CODE", "tags": "nlp, kaggle, distillbert, pairwise", "date": "2022-09-10 11:15:02 +0900", "snippet": "Preprocess이것저것 걸러내기class PairwisePreprocessor(Preprocessor): def __init__(self, **args): self.__dict__.update(args) super(PairwisePreprocessor, self).__init__(**args) nltk.download('wordnet') nltk.download('omw-1.4') self.stemmer = WordNetLemmatizer() def preprocess_text(self, document): # Remove all the special characters document = re.sub(r'\\W', ' ', str(document)) # remove all single characters document = re.sub(r'\\s+[a-zA-Z]\\s+', ' ', document) # Remove single characters from the start document = re.sub(r'\\^[a-zA-Z]\\s+', ' ', document) # Substituting multiple spaces with single space document = re.sub(r'\\s+', ' ', document, flags=re.I) # Removing prefixed 'b' document = re.sub(r'^b\\s+', '', document) # Converting to Lowercase document = document.lower() # return document # Lemmatization tokens = document.split() tokens = [self.stemmer.lemmatize(word) for word in tokens] tokens = [word for word in tokens if len(word) &gt; 3] preprocessed_text = ' '.join(tokens) return preprocessed_text def run(self): if os.path.exists(self.pairwise_train_path) and os.path.exists(self.pairwise_val_path): print('pairwise_train_df and val_df already exists') train_df = pd.read_csv(self.pairwise_train_path) val_df = pd.read_csv(self.pairwise_val_path) else: print('generate_train_df and val_df') train_df, val_df, _, _ = super().run() train_df.source = train_df.source.apply(self.preprocess_text) val_df.source = val_df.source.apply(self.preprocess_text) train_df.to_csv(self.pairwise_train_path) val_df.to_csv(self.pairwise_val_path) if os.path.exists(self.dict_cellid_source_path): dict_cellid_source = joblib.load(self.dict_cellid_source_path) else: df = pd.concat([train_df, val_df]) dict_cellid_source = dict(zip(df['cell_id'].values, df['source'].values)) joblib.dump(dict_cellid_source, self.dict_cellid_source_path) return train_df, val_df, dict_cellid_sourcePairwise datasetTripletpairwise 이니 triplet:(문장 A, 문장 B, isNext or notNext)들을 준비해준다. 실험 결과 최적 비율은 True:False = 1:9이고, 5:5는 데이터의 개수가 너무 적어진다.def generate_triplets(df, args, mode='train'): print(f'generate {mode} triplets') triplets = [] drop_sz = 1000 if args.debug else 10000 random_drop = np.random.random(size=drop_sz) &gt; .9 count = 0 for id, df_tmp in tqdm(df.groupby('id')): df_tmp_markdown = df_tmp[df_tmp['cell_type'] == 'markdown'] df_tmp_code = df_tmp[df_tmp['cell_type'] == 'code'] df_tmp_code_rank = df_tmp_code['rank'].values df_tmp_code_cell_id = df_tmp_code['cell_id'].values for cell_id, rank in df_tmp_markdown[['cell_id', 'rank']].values: # cell_id의 마크다운 바로 뒤에 나오는 코드셀이면 True labels = np.array([(r == (rank+1)) for r in df_tmp_code_rank]).astype(int) for cid, label in zip(df_tmp_code_cell_id, labels): count += 1 if label == 1 or random_drop[count % drop_sz] or mode=='test': triplets.append([cell_id, cid, label]) return tripletsPairwise-datasetclass PairwiseDataset(Dataset): def __init__(self, df, args): self.df = df self.max_len = args.total_max_len self.tokenizer = AutoTokenizer.from_pretrained(args.model_name_or_path) self.dict_cellid_source = joblib.load(args.dict_cellid_source_path) def __getitem__(self, index): row = self.df[index] label = row[-1] txt = self.dict_cellid_source[row[0]] + \\ '[SEP]' + self.dict_cellid_source[row[1]] inputs = self.tokenizer.encode_plus( txt, None, add_special_tokens=True, max_length=self.max_len, padding='max_length', return_token_type_ids=True, truncation=True ) ids = torch.LongTensor(inputs['input_ids']) mask = torch.LongTensor(inputs['attention_mask']) return ids, mask, torch.FloatTensor([label]) def __len__(self): return len(self.df)할거 하고 데이터 로더 반환def pairwise_data_setup(train_df, val_df, args): train_triplets = generate_triplets(train_df, args, mode='train') # test 모드는 drop없이 다 때려박기 때문에 데이터 개수가 많다. val_triplets = generate_triplets(val_df, args, mode='test') train_ds = PairwiseDataset(train_triplets, args) val_ds = PairwiseDataset(val_triplets, args) train_loader = DataLoader(train_ds, batch_size=args.batch_size, shuffle=True, num_workers=8, pin_memory=False, drop_last=True) val_loader = DataLoader(val_ds, batch_size=args.batch_size, shuffle=False, num_workers=8, pin_memory=False, drop_last=False) return train_loader, val_loaderTrain학습에 필요한 이것저것 준비def pairwise_train_setup(args): model = PairwiseModel(model_path=args.model_name_or_path) num_train_optimization_steps = args.num_train_steps optimizer = torch.optim.Adam(filter(lambda p: p.requires_grad, model.parameters()), lr=3e-4, betas=(0.9, 0.999), eps=1e-8) # 1e-08) scheduler = get_linear_schedule_with_warmup( optimizer=optimizer, num_warmup_steps=0.05*num_train_optimization_steps, num_training_steps=num_train_optimization_steps, ) scaler = torch.cuda.amp.GradScaler() return model, optimizer, scheduler, scalertrain 함수 본문이진 분류 문제로 치환하면서 BCELoss를 사용하게 되었는데, BCELoss는 amp를 못쓴다. 따라서 BCEwithLogitLoss인가 뭔가 그걸 사용하고, 위 모델 아웃풋에도 좀 손대서 amp로 돌렸다. 바꾼 코드는 어딨는지 까먹었고, 찾기 귀찮다. 아래 코드도 잘 돌아간다 (대신 오래걸림)def pairwise_train(model, train_loader, val_loader, optimizer, scheduler, scaler, val_df, df_orders, args): criterion = torch.nn.BCELoss() for e in range(args.epoch, args.epochs): model.train() tbar = tqdm(train_loader, file=sys.stdout, position=0, leave=True) loss_list = [] preds = [] labels = [] for idx, data in enumerate(tbar): inputs, target = read_data(data) # with torch.cuda.amp.autocast(): # pred = model(*inputs) # loss = criterion(pred, target) # scaler.scale(loss).backward() optimizer.zero_grad() pred = model(*inputs) loss = criterion(pred, target) loss.backward() # scaler.step(optimizer) # scaler.update() optimizer.step() scheduler.step() loss_list.append(loss.detach().cpu().item()) preds.append(pred.detach().cpu().numpy().ravel()) labels.append(target.detach().cpu().numpy().ravel()) avg_loss = np.round(np.mean(loss_list), 4) tbar.set_description( f\"Epoch {e+1} Loss: {avg_loss} lr: {scheduler.get_last_lr()}\") y_val, y_pred = pairwise_validate(model, val_loader) y_pred = get_preds(y_pred, val_df) val_df['pred'] = val_df.groupby(['id', 'cell_type'])['rank'].rank(pct=True) val_df.loc[val_df['cell_type'] == 'markdown', 'pred'] = y_pred y_dummy = val_df.sort_values('pred').groupby('id')['cell_id'].apply(list) print(\"Preds score\", kendall_tau(df_orders.loc[y_dummy.index], y_dummy)) if not os.path.exists(args.output_path): os.mkdir(args.output_path) torch.save({ 'epoch': e, 'model_state_dict': model.state_dict(), 'optimizer_state_dict': optimizer.state_dict(), 'scheduler_state_dict': scheduler.state_dict(), 'scaler_state_dict': scaler.state_dict(), }, args.output_path + f'/chekcpoint_{e}.pt') torch.save(model.state_dict(), args.output_path + f'/model_epoch_{e}.bin')Validatepairwise 예측으로 생긴 로짓을 가지고 다시 순서를 매겨야한다. 조금 골때리는 부분. 원본 코드 작성자의 방법과 다른 방식도 이것저것 시도해 보았으나 큰 성능향상을 느끼지 못하였다.def validate(model, val_loader, mode='train'): model.eval() tbar = tqdm(val_loader, file=sys.stdout) preds = np.zeros(len(val_loader.dataset), dtype='float32') labels = [] count = 0 with torch.no_grad(): for idx, data in enumerate(tbar): inputs, target = read_data(data) pred = model(inputs[0], inputs[1]).detach().cpu().numpy().ravel() preds[count:count+len(pred)] = pred count += len(pred) if mode=='test': labels.append(target.detach().cpu().numpy().ravel()) if mode=='test': return preds else: return np.concatenate(labels), np.concatenate(preds)preds_copy = y_testpred_vals = []count = 0for id, df_tmp in tqdm(test_df.groupby('id')): df_tmp_mark = df_tmp[df_tmp['cell_type']=='markdown'] df_tmp_code = df_tmp[df_tmp['cell_type']!='markdown'] df_tmp_code_rank = df_tmp_code['rank'].rank().values N_code = len(df_tmp_code_rank) N_mark = len(df_tmp_mark) preds_tmp = preds_copy[count:count+N_mark * N_code] count += N_mark * N_code for i in range(N_mark): pred = preds_tmp[i*N_code:i*N_code+N_code] softmax = np.exp((pred-np.mean(pred)) *20)/np.sum(np.exp((pred-np.mean(pred)) *20)) rank = np.sum(softmax * df_tmp_code_rank) pred_vals.append(rank)del modeldel test_triplets[:]del dict_cellid_sourcegc.collect()Resultpublic score - 0.8171" }, { "title": "distillbert(small) - baseline 0.7499", "url": "/posts/ai4code-baseline/", "categories": "NLP, KAGGLE, AI4CODE", "tags": "nlp, kaggle, distillbert", "date": "2022-09-10 11:15:01 +0900", "snippet": "Load dataraw data를 dataframe으로 바꿔주는 함수def get_df(data_dir, num_rows, folder='train'): paths_train = list((data_dir / folder).glob('*.json'))[:num_rows] notebooks_train = [ read_notebook(path) for path in tqdm(paths_train, desc='Train NBs') ] df = ( pd.concat(notebooks_train) .set_index('id', append=True) .swaplevel() .sort_index(level='id', sort_remaining=False) ) return dftrain dataset의 정답 (마크다운 셀의 순서)를 추출하는 함수def get_df_orders(data_dir): df_orders = pd.read_csv( data_dir / 'train_orders.csv', index_col='id', squeeze=True ).str.split() return df_orders인수로 받아들인 df의 순서를 구하는 함수def get_ranks(base, derived): return [base.index(d) for d in derived]def get_df_ranks(df, data_dir): df_orders = get_df_orders(data_dir) df_orders_ = df_orders.to_frame().join( df.reset_index('cell_id').groupby('id')['cell_id'].apply(list), how='right' ) ranks = {} for id_, cell_order, cell_id in df_orders_.itertuples(): ranks[id_] = {'cell_id': cell_id, 'rank': get_ranks(cell_order, cell_id)} df_ranks = ( pd.DataFrame .from_dict(ranks, orient='index') .rename_axis('id') .apply(pd.Series.explode) .set_index('cell_id', append=True) ) return df_rankstrain_dataset의 부모 노트북(fork from)을 구하는 함수def get_df_ancestors(data_dir): df_ancestors = pd.read_csv(data_dir / 'train_ancestors.csv', index_col='id') return df_ancestorsdf를 train과 valid로 나누는 함수def get_df_train_valid(df, valid_size, random_state): NVALID = valid_size # size of validation set splitter = GroupShuffleSplit(n_splits=1, test_size=NVALID, random_state=0) train_ind, val_ind = next(splitter.split(df, groups=df[\"ancestor_id\"])) train_df = df.loc[train_ind].reset_index(drop=True) val_df = df.loc[val_ind].reset_index(drop=True) return train_df, val_df대충 전처리하고, train과 valid로 나눈다.from sklearn.model_selection import GroupShuffleSplitNUM_TRAIN = 10000df = get_df(data_dir, num_rows=NUM_TRAIN)# NUM_TRAIN = 10000df_orders = get_df_orders(data_dir)df_ranks = get_df_ranks(df, data_dir)df_ancestors = get_df_ancestors(data_dir)df = df.reset_index().merge(df_ranks, on=['id', 'cell_id']).merge(df_ancestors, on=['id'])df['pct_rank'] = df['rank'] / df.groupby('id')['cell_id'].transform('count')train_df, val_df = get_df_train_valid(df, valid_size=.1, random_state=0)train_df_mark = train_df[train_df['cell_type'] == 'markdown'].reset_index(drop=True)val_df_mark = val_df[val_df['cell_type'] == 'markdown'].reset_index(drop=True)Train흔한 bert 모델 fine tuning 의 모오습from torch.utils.data import Datasetclass MarkdownDataset(Dataset): def __init__(self, df, max_len, tokenizer): super().__init__() self.df = df.reset_index(drop=True) self.max_len = max_len self.tokenizer = tokenizer def __getitem__(self, index): row = self.df.iloc[index] inputs = self.tokenizer.encode_plus( row.source, None, add_special_tokens=True, max_length=self.max_len, padding='max_length', return_token_type_ids=True, truncation=True ) ids = torch.LongTensor(inputs['input_ids']) mask = torch.LongTensor(inputs['attention_mask']) return ids, mask, torch.FloatTensor([row.pct_rank]) def __len__(self): return self.df.shape[0]class MarkdownModel(nn.Module): def __init__(self, distill_bert): super(MarkdownModel, self).__init__() self.distill_bert = distill_bert self.top = nn.Linear(768, 1) def forward(self, ids, mask): # (32, 128, 768) x = self.distill_bert(ids, mask)[0] # (32, 1, 768): [CLS] x = self.top(x[:, 0, :]) return xfrom torch.utils.data import DataLoaderBS = 32NW = 8MAX_LEN = 128# 1.Get bert &amp; tokenizerdistill_bert = DistilBertModel.from_pretrained(BERT_PATH)tokenizer = DistilBertTokenizer.from_pretrained(BERT_PATH, do_lower_case=True)# 2.Get Datasettrain_ds = MarkdownDataset(train_df_mark, max_len=MAX_LEN, tokenizer=tokenizer)val_ds = MarkdownDataset(val_df_mark, max_len=MAX_LEN, tokenizer=tokenizer)# 3.Get DataLoadertrain_loader = DataLoader(train_ds, batch_size=BS, shuffle=True, num_workers=NW, pin_memory=False, drop_last=True)val_loader = DataLoader(val_ds, batch_size=BS, shuffle=False, num_workers=NW, pin_memory=False, drop_last=False)간단한 스케줄러, 옵티마이저 등등 필요한 함수와 validate 및 train 함수from sklearn.metrics import mean_squared_errordef adjust_lr(optimizer, epoch): if epoch &lt; 1: lr = 5e-5 elif epoch &lt; 2: lr = 1e-3 elif epoch &lt; 3: lr = 1e-4 else: lr = 1e-5 for p in optimizer.param_groups: p['lr'] = lr return lrdef get_optimizer(net): optimizer = torch.optim.Adam(filter(lambda p: p.requires_grad, net.parameters()), lr=3e-4, betas=(.9, .999), eps=1e-08) return optimizer# divide input and target from train_loaderdef read_data(data): return tuple(d.cuda() for d in data[:-1]), data[-1].cuda()def validate(model, val_loader): model.eval() tbar = tqdm(val_loader, file=sys.stdout) preds = [] labels = [] with torch.no_grad(): for idx, data in enumerate(tbar): inputs, target = read_data(data) pred = model(inputs[0], inputs[1]) preds.append(pred.detach().cpu().numpy().ravel()) labels.append(target.detach().cpu().numpy().ravel()) return np.concatenate(labels), np.concatenate(preds)def train(model, train_loader, val_loader, epochs): np.random.seed(0) optimizer = get_optimizer(model) criterion = torch.nn.MSELoss() for e in range(epochs): model.train() tbar = tqdm(train_loader, file=sys.stdout) lr = adjust_lr(optimizer, e) loss_list = [] preds = [] labels = [] for idx, data in enumerate(tbar): # inputs = (ids, mask) # target = torch.FloatTensor([row.pct_rank]) inputs, target = read_data(data) optimizer.zero_grad() pred = model(inputs[0], inputs[1]) loss = criterion(pred, target) loss.backward() optimizer.step() loss_list.append(loss.detach().cpu().item()) preds.append(pred.detach().cpu().numpy().ravel()) labels.append(target.detach().cpu().numpy().ravel()) avg_loss = np.round(np.mean(loss_list), 4) tbar.set_description(f'Epoch {e+1} Loss: {avg_loss} lr: {lr}') y_val, y_pred = validate(model, val_loader) print('Validation MSE: ', np.round(mean_squared_error(y_val, y_pred), 4)) print() return model, y_predmodel = MarkdownModel(distill_bert)model = model.cuda()model, y_pred = train(model, train_loader, val_loader, epochs=1)Epoch 1 Loss: 0.0584 lr: 5e-05: 100% 4439/4439 [14:54&lt;00:00, 5.25it/s]100% 461/461 [00:41&lt;00:00, 16.33it/s]Validation MSE: 0.051Evaluatefrom bisect import bisectdef count_inversions(a): inversions = 0 sorted_so_far = [] for i, u in enumerate(a): j = bisect(sorted_so_far, u) inversions += i - j sorted_so_far.insert(j, u) return inversionsdef kendall_tau(ground_truth, predictions): total_inversions = 0 total_2max = 0 # twice the maximum possible inversions across all instances for gt, pred in zip(ground_truth, predictions): ranks = [gt.index(x) for x in pred] # rank predicted order in terms of ground truth total_inversions += count_inversions(ranks) n = len(gt) total_2max += n * (n - 1) return 1 - 4 * total_inversions / total_2maxval_df['pred'] = val_df.groupby(['id', 'cell_type'])['rank'].rank(pct=True)val_df.loc[val_df['cell_type'] == 'markdown', 'prde'] = y_predy_dummy = val_df.sort_values('pred').groupby('id')['cell_id'].apply(list)kendall_tau(df_orders.loc[y_dummy.index], y_dummy)0.9221784760258563test_df = get_df(data_dir, num_rows=None, folder='test').reset_index()test_df[\"rank\"] = test_df.groupby([\"id\", \"cell_type\"]).cumcount()test_df[\"pred\"] = test_df.groupby([\"id\", \"cell_type\"])[\"rank\"].rank(pct=True)test_df[\"pct_rank\"] = 0test_ds = MarkdownDataset(test_df[test_df[\"cell_type\"] == \"markdown\"].reset_index(drop=True), max_len=MAX_LEN, tokenizer=tokenizer)test_loader = DataLoader(test_ds, batch_size=BS, shuffle=False, num_workers=NW, pin_memory=False, drop_last=False)len(test_ds), test_ds[0]Train NBs: 100% 4/4 [00:00&lt;00:00, 44.16it/s](43, (tensor([ 101, 1001, 25169, 2951, 100, 2292, 1005, 1055, 4094, 1996, 2951, 2061, 7473, 2050, 2064, 2022, 4162, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), tensor([0.])))_, y_test = validate(model, test_loader)100% 2/2 [00:01&lt;00:00, 1.13it/s]test_df.loc[test_df[\"cell_type\"] == \"markdown\", \"pred\"] = y_testtest_dfSubmitsub_df = test_df.sort_values(\"pred\").groupby(\"id\")[\"cell_id\"].apply(lambda x: \" \".join(x)).reset_index()sub_df.rename(columns={\"cell_id\": \"cell_order\"}, inplace=True)sub_df.head()ResultRun: 1068.6s - GPUPublic score : 0.7499Link" }, { "title": "Google AI4Code", "url": "/posts/ai4code/", "categories": "NLP, KAGGLE, AI4CODE", "tags": "nlp, kaggle", "date": "2022-09-10 11:15:00 +0900", "snippet": "Overview이 대회의 목적은 파이썬 (주피터) 노트북의 코드와 코멘트 사이의 관계를 이해하는 것이다. 당신은 주어진 노트북의 코드셀의 순서에 따라, 어떤 자연어가 코드와 연관되는지 파악하여 마크다운 셀의 순서를 재구성 해야한다.Context구글과 알파벳의 리서치 팀은 머신러닝이 소프트웨어 개발자들을 보조할 수 있는 새로운 방법을 찾고있으며, 더 많은 개발자 커뮤니티의 구성원들이 이 분야를 탐험하는 것을 돕고 싶어한다. 파이썬 노트북은 많은 표준 소스 코드와 달리 서술형 형식을 따르는 경우가 많으며, 해당 코드 셀에 대한 프로그래머의 의도를 설명하는 마크다운으로 구현된 주석 셀이 있기 때문에, 좋은 학습기회를 제공한다. 코드와 마크다운 사이의 관계를 이해하면 모델 학습을 위한 더 나은 데이터 필터링 및 전처리 파이프라인의 구축 또는 노트북의 가독성에 대한 자동 평가와 같은 AI 보조 개발의 많은 측면에 새로운 개선을 제공할 수 있다.Metricsfrom bisect import bisectdef count_inversions(a): inversions = 0 sorted_so_far = [] for i, u in enumerate(a): j = bisect(sorted_so_far, u) inversions += i - j sorted_so_far.insert(j, u) return inversionsdef kendall_tau(ground_truth, predictions): total_inversions = 0 total_2max = 0 # twice the maximum possible inversions across all instances for gt, pred in zip(ground_truth, predictions): ranks = [gt.index(x) for x in pred] # rank predicted order in terms of ground truth total_inversions += count_inversions(ranks) n = len(gt) total_2max += n * (n - 1) return 1 - 4 * total_inversions / total_2maxSubmission File테스트 셋의 각 노트북 id 별로, cell_order 컬럼을 예측해야 하며, 이 셀들의 올바른 순서는 cell ids의 측면에서여야 한다. 이 파일은 다음과 같은 머릿말을 포함해야 하며 다음의 형식을 따라야 한다.💡 id,cell_order0009d135ece78d,ddfd239c c6cd22db 1372ae9b ...0010483c12ba9b,54c7cab3 fe66203e 7844d5f8 ...0010a919d60e4f,aafc3d23 80e077ec b190ebb4 ...0028856e09c5b7,012c9d02 d22526d1 3ae7ece3 ...etc." }, { "title": "BERT 사전학습", "url": "/posts/bert-pretrain/", "categories": "NLP, BERT", "tags": "nlp, bert", "date": "2022-09-09 12:40:00 +0900", "snippet": "이 절에서는 BERT를 사전학습 시키는 방법을 알아본다. 그런데 사전 학습이란 무엇일까? 모델을 하나 학습시켜야 된다고 가정해보자. 일단 특정 태스크에 대한 방대한 데이터셋으로 모델을 학습시키고 학습된 모델을 저장한다. 그 다음으로, 새 태스크가 주어지면 임의 가중치로 모델을 초기화하는 대신 이미 학습된 모델의 가중치로 모델을 초기화한다. 즉, 모델이 이미 대규모 데이터셋에서 학습되었으므로 새 태스크를 위해 새로운 모델로 처음부터 학습시키는 대신 사전 학습된 모델을 사용하고 새로운 태스크에 따라 가중치를 조정한다. 이런 방식이 사전학습의 대표적인 유형이다.BERT는 MLM과 NSP라는 두 가지 재미있는 태스크를 이용해 거대한 말뭉치를 기반으로 사전 학습된다. 사전 학습 후 사전 학습된 BERT를 저장해두고, 새로운 태스크가 주어질 경우 BERT를 처음부터 학습시키는 대신 사전 학습된 BERT를 사용한다. 즉, 사전 학습된 BERT를 기반으로 새 태스크에 대한 가중치를 조정 (파인 튜닝)한다.이제 BERT가 어떻게 사전 학습되는지 자세히 알아볼 것이다. 그전에 먼저 BERT가 허용하는 방식으로 입력 데이터를 구조화하는 방법부터 살펴보자.2.4.1 BERT의 입력 표현BERT에 데이터를 입력하기 전에 다음 세 가지 임베딩 레이어를 기반으로 입력 데이터를 임베딩으로 변환해야 한다. 토큰 임베딩 (token embedding) 세그먼트 임베딩 (segment embedding) 위치 임베딩 (position embedding)토큰 임베딩먼저, 토큰 임베딩 레이어 차례다. 다음 두 문장으로 살펴보자. A 문장: Paris is a beautiful city. B 문장: I love Paris.먼저 여기에 표시된 것처럼 두 문장 모두 토큰화해 토큰들을 추출한다. 이 예에서는 토큰을 소문자로 변환하지 않을 것이다.다음으로, 첫 번째 문장의 시작 부분에만 [CLS] 토큰이라는 새 토큰을 추가한다.tokens = [\"[CLS]\", \"Paris\", \"is\", \"a\", \"beautiful\", \"city\", \"I\", \"love\", \"Paris\"]그런 다음 모든 문장 끝에 [SEP]라는 새 토큰을 추가한다.tokens = [\"[CLS]\", \"Paris\", \"is\", \"a\", \"beautiful\", \"city\", \"[SEP]\", \"I\", \"love\", \"Paris\", \"[SEP]\"][CLS] 토큰은 첫 번째 문장의 시작 부분에만 추가되고 [SEP] 토큰은 모든 문장의 끝에 추가한다. [CLS] 토큰은 분류 작업에 사용되며 [SEP] 토큰은 모든 문장의 끝을 나타내는 데 사용된다. 이 두 스페셜 토큰인 [CLS]와 [SEP]가 어떤 기능을 수행하는지 이 장에서 자세히 알아볼 것이다.이제 모든 토큰을 BERT에 입력하기 전에 토큰 임베딩이라는 임베딩 레이어를 사용해 토큰을 임베딩으로 변환한다. 토큰 임베딩의 변수들은 사전학습이 진행되며 학습된다. [그림 2-8]에서 볼 수 있듯이 모든 토큰에 대한 임베딩이 있다. 즉, $E_{cls}$는 [CLS] 토큰의 임베딩을 나타내며, $E_{paris}$는 Paris 토큰의 임베딩을 나타낸다. 그림 2-8 토큰 임베딩세그먼트 임베딩세그먼트 임베딩은 주어진 두 문장을 구별하는 데 사용되낟. 앞에서 활용된 문장으로 세그먼트 임베딩을 살펴보자.tokens = [\"[CLS]\", \"Paris\", \"is\", \"a\", \"beautiful\", \"city\", \"[SEP]\", \"I\", \"love\", \"Paris\", \"[SEP]\"]이제 [SEP] 토큰과 별도로 두 문장을 구분하기 위해 모델에 일종의 지표를 제공해야 한다. 이를 위해 세그먼트 임베딩 레이어에 입력 토큰을 제공한다.세그먼트 임베딩 레이어는 입력에 대한 출력으로 $E_A, E_B$만 반환한다. 입력 토큰이 A 문장에 속하면 $E_A$에 매핑되고, B 문장에 속하면 $E_B$에 매핑된다.[그림 2-9]에 표시된 대로 문장 A의 모든 토큰은 $E_A$에 매핑되고, B 문장의 모든 토큰은 $E_B$에 매핑된다. 그림 2-9 세그먼트 임베딩: 문장이 2개인 경우그럼 문장이 하나만 있는 경우 세그먼트 임베딩은 어떻게 될까? “Paris is a beautiful city”라는 문장만 있다고 가정하면, 다음과 같이 문장의 모든 토큰이 $E_A$에 매핑된다. 그림 2-10 세그먼트 임베딩: 문장이 1개인 경우위치 임베딩다음으로 위치 임베딩이 있다. 전 장에서 트랜스포머가 어떤 반복 메커니즘도 사용하지 않고 모든 단어를 병렬로 처리하므로 단어 순서와 관련된 정보를 제공해야 한다는 것을 배웠다. 이때 위치 인코딩을 사용했다.BERT는 본질적으로 트랜스포머의 인코더이므로 BERT에 데이터를 직접 입력하기 전에 문장에서 단어 (토큰)의 위치에 대한 정보를 제공해야 한다. 결국 우리는 위치 임베딩이라는 레이어를 사용해 문장의 각 토큰에 대한 위치 임베딩 출력을 얻게 된다.[그림 2-11]에서 [CLS]의 위치 임베딩인 $E_0$와 Paris 토큰의 위치 임베딩인 $E_1$ 등을 확인할 수 있다. 그림 2-11 위치 임베딩최종 입력 데이터 표현이제 최종 입력 데이터 표현을 살펴보자. [그림 2-12]에 표시된 것처럼 먼저 주어진 입력 문장을 토큰으로 변환하고 토큰을 토큰 임베딩, 세그먼트 임베딩, 위치 임베딩 레이어에 공급하고 임베딩을 얻는다. 그 다음으로 모든 임베딩을 합산헤 BERT에 입력으로 제공한다. 그림 2-12 입력의 최종 표현지금까지 세 가지 임베딩 레이어를 사용해 입력을 임베딩으로 변환하는 방법을 배웠다. 다음으로 BERT에서 사용하는 워드피스 토크나이저에 대해 알아보자.워드피스 토크나이저BERT는 워드피스 토크나이저라는 특별한 유형의 토크나이저를 사용하며, 이는 하위 단어 토큰화 알고리즘을 기반으로 한다. 예제를 통해 워드피스 토크나이저가 어떻게 작동하는지 이해해보자. 먼저 다음 문장이 주어졌다고 가정하자. Let us start pretraining the model.워드피스 토크나이저를 사용해 문장을 토큰화하면 다음과 같은 토큰을 얻을 수 있다.tokens = [\"let\", \"us\", \"start\", \"pre\", \"##train\", \"##ing\", \"the\", \"model\"]워드피스 토크나이저를 사용해 문장을 토큰화하면 개별 단어가 pre, ##train, ##ing와 같은 하위단어(subword)로 분할되는 것을 볼 수있따. 왜 하위 단어로 분할하는 것일까?BERT는 워드피스 토크나이저를 사용해 토큰화할 때 단어가 어휘 사전에 있는지 확인한다. 단어가 어휘 사전에 있으면 그 단어를 토큰으로 사용하고, 단어가 어휘 사전에 없으면 그 단어를 하위 단어로 분할해 하위 단어가 어휘 사전에 있는지 확인한다. 하위 단어가 어휘 사전에 있으면 이를 토큰으로 사용한다. 만약 하위 단어가 어휘 사전에 없으면 다시 하위 단어로 분할하여 다시 하위 단어로 분할한다. 이런 식으로 개별 문자에 도달할 때 까지 어휘 사전을 기반으로 하위 단어를 계속 분할하고 확인한다. 이 방식은 어휘 사전 이외(out-of-vocabulary, OOV)의 단어를 처리하는데 효과적이다.BERT 어휘 사전 크기는 3만 토큰이다. 입력 단어가 3만 토큰에 속하면 이를 토큰으로 사용하고 그렇지 않으면 하위 단어로 분할하여 하위 단어가 이 3만 토큰에 속하는지 확인한다. 알고리즘은 개별 문자에 도달할 때까지 어휘 사전(3만 토큰)으로 하위 단어를 계속 분할하고 확인한다.이 예에서 pretraining이라는 단어는 BERT의 어휘사전에 없기 때문에 이 단어를 pre, ##train, ##ing와 같은 하위단어로 나눈다. ##train과 ##ing 토큰 앞의 해시 기호는 하위 단어임을 나타내고 앞에 다른 단어가 있음을 의미한다. 이제 어휘 사전에 ##train과 ##ing하위 단어가 있는지 확인하고, 이들은 어휘 사전에 존재하기 때문에 다시 나누지 않고 토큰으로 사용한다.결국, 워드피스 토크나이저를 사용해 다음과 같은 토큰들을 얻게 된다.tokens = [\"let\", \"us\", \"start\", \"pre\", \"##train\", \"##ing\", \"the\", \"model\"]이후 문장 시작 부분에 [CLS] 토큰을 추가하고 문장 끝 부분에 [SEP] 토큰을 추가한다.앞에서 배운 것처럼 입력 토큰을 토큰, 세그먼트, 위치 임베딩 레이어에 입력해 각 임베딩을 얻고 이들 임베딩을 합한 다음 BERT에 입력한다. 워드피스 토크나이저의 작동 방식과 어휘 사전 구축 방식은 2.5절 다른 토크나이저와 함께 자세히 다룬다.2.4.2 학습 전략BERT는 다음 두 가지 태스크에 대해 사전 학습된다. 마스크 언어 모델링 (Masked Language Modeling, MLM) 다음 문장 예측 (Next Sentence Prediction, NSP)이 두 가지 학습 전략을 차례로 살펴 봄으로써 어떻게 작동하는지 이해해보자. MLM 태스크를 설명하기 전에 먼저 언어 모델링 태스크를 살펴본다.언어 모델링언어 모델링 (Language Modeling)은 일반적으로 임의의 문장이 주어지고 단어를 순서대로 보면서 다음 단어를 예측하도록 모델을 학습하는 것이다. 언어 모델링은 다음 두 가지로 분류할 수 있다. 자동 회귀 언어 모델링 (auto-regressive language modeling) 자동 인코딩 언어 모델링 (auto-encoding language modeling) ### 자동 회귀 언어 모델링 자동 회구 언어 모델링은 다시 다음 두 가지 방식으로 구분할 수 있다. 전방 (왼쪽에서 오른쪽으로) 예측 (forward(left-to-right) prediction) 후방 (오른쪽에서 왼쪽으로) 예측 (backward(right-to-left)) prediction) 이 두 가지 방법이 어떻게 동작하는지 예제로 살펴보자. “Paris is a beautiful city. I love Paris” 라는 문장이 주어졌을 때 다음과 같이 “city”라는 단어를 제거하고 공백을 추가해본다. Paris is a beautiful ___. I love Paris. 이제 모델은 공백을 예측해야 한다. 전방 예측을 사용하는 경우 모델은 예측을 사용하기 위해 다음과 같이 왼쪽에서 오른쪽으로 공백까지의 모든 단어를 읽는다. Paris is a beautiful ___. 후방 예측을 사용하면 예측을 수행하기 위해 모델은 다음과 같이 오른쪽에서 왼쪽으로 공백까지 모든 단어를 읽는다. ___. I love Paris. 자동 회귀 모델은 원래 단방향이므로 한 방향으로만 문장을 읽는다. 마스크 언어 모델링 (MLM)BERT는 자동 인코딩 언어 모델로, 예측을 위해 문장을 양방향으로 읽는다. 마스크 언어 모델링은 주어진 입력 문장에서 전체 단어의 15%를 무작위로 마스킹하고 마스크된 단어를 예측하도록 모델을 학습시키는 것이다. 마스크된 단어를 예측하기 위해 모델은 양방향으로 문장을 읽고 마스크된 단어를 예측하려 시도한다.마스크 언어 모델링이 어떻게 작동하는지 예제를 통해 살펴보자. 앞에서 살펴본 문장 (Paris is a beautiful city, I love Paris)을 토큰화한다.tokens = [\"Paris\", \"is\", \"a\", \"beautiful\", \"city\", \"I\", \"love\", \"Paris\"]첫 번째 문장의 시작 부분에 [CLS] 토큰을 추가하고 문장 끝에 [SEP] 토큰을 추가한다.tokens = [\"[CLS]\", \"Paris\", \"is\", \"a\", \"beautiful\", \"city\", \"[SEP]\", \"I\", \"love\", \"Paris\", \"[SEP]\"]다음으로, 토큰의 15%를 무작위로 마스킹한다. 다음과 같이 city라는 단어를 마스킹한 다음 [MASK] 토큰으로 바꾼다.tokens = [\"[CLS]\", \"Paris\", \"is\", \"a\", \"beautiful\", \"[MASK]\", \"[SEP]\", \"I\", \"love\", \"Paris\", \"[SEP]\"]“city”라는 단어를 [MASK] 토큰으로 대체했다. 이젠 마스크된 토큰을 예측하기 위한 BERT를 학습시킨다.여기에 작은 문제가 있다. 위와 같은 방식으로 토큰을 마스킹하면 사전학습과 파인튜닝 사이에 불일치가 생기게 된다. [MASK] 토큰을 예측해 BERT를 사전학습시키고, 학습 시킨 후에는 감정 분석과 같은 다운스트림 태스크를 위해 사전 학습된 BERT를 파인 튜닝한다. 그런데 파인 튜닝에는 입력에 [MASK] 토큰이 없다. 이 때문에 BERT가 사전 학습되는 방식과 파인 튜닝에 사용되는 방식 간에 불일치가 발생한다.이 문제를 극복하기 위해 80-10-10% 규칙을 사용한다. 문장에서 토큰의 15%를 무작위로 마스킹한다는 것을 확인했다. 그럼 15% 토큰에 대해 다음을 수행한다. 15% 중 80%의 토큰(실제 단어)를 [MASK] 토큰으로 교체한다. 적용 결과는 다음과 같다. tokens = [\"[CLS]\", \"Paris\", \"is\", \"a\", \"beautiful\", \"[MASK]\", \"[SEP]\", \"I\", \"love\", \"Paris\", \"[SEP]\"] 15% 증 10%의 토큰(실제 단어)을 임의의 토큰(임의 단어)로 교체한다. 적용 결과는 다음과 같다. tokens = [\"[CLS]\", \"Paris\", \"is\", \"a\", \"beautiful\", \"love\", \"[SEP]\", \"I\", \"love\", \"Paris\", \"[SEP]\"] 15% 중 나머지 10%의 토큰은 어떤 변경도 하지 않는다. 적용결과는 다음과 같다. tokens = [\"[CLS]\", \"Paris\", \"is\", \"a\", \"beautiful\", \"city\", \"[SEP]\", \"I\", \"love\", \"Paris\", \"[SEP]\"] 토큰화 및 마스킹 후에 입력 토큰을 토큰, 세그먼트, 위치 임베딩 레이어에 입력해 입력 임베딩을 얻는다.이제 이 입력 임베딩을 BERT에 제공한다.[그림 2-13]과 같이 BERT는 입력을 받은 다음 각 토큰의 표현 벡터를 출력으로 반환한다. $R_{CLS}$는 [CLS]토큰의 표현 벡터를 의미하고, $R_{Paris}$는 Paris토큰의 표현 벡터를 의미한다. 이 예에서는 12개의 인코더 레이어, 12개의 어텐션 헤드, 768개의 은닉 유닛이 있는 BERT-base를 사용한다. BERT-base 모델을 사용하기 때문에 각 토큰의 표현 벡터 크기는 768이 된다. 그림 2-13 BERT[그림 2-13]에서 각 토큰의 표현 $R$을 얻었다. 이제 이러한 표현으로 마스크된 토큰을 어떻게 예측하게 될까?마스크된 토큰을 예측하기 위해 BERT에서 반환된 마스크된 토큰 $R_{MASK}$의 표현을 소프트맥스 활성화를 통해 피드포워드 네트워크에 입력한다. 피드포워드 네트워크는 다음그림과 같이 $R_{MASK}$ 단어가 마스크된 단어가 될 확률을 반환한다. 여기서는 복잡함을 줄이기 위해 입력 임베딩 레이어 (토큰, 세그먼트, 위치)를 표시하지 않았다. 그림 2-14 마스크된 토큰 예측[그림 2-14]에서 볼 수 있듯이 “city”라는 단어가 마스크된 단어일 확률이 높다. 이 경우 마스크된 단어는 “city”로 예측된다.학습 초기에는 BERT의 피드포워드 네트워크 및 인코더 계층의 가중치가 최적이 아니므로 모델이 올바른 확률을 반환하지 않는다. 그러나 역전파를 통한 일련의 반복 과정을 거치며 BERT 피드포워드 네트워크 및 인코더 계층의 가중치 업데이트가 반복되면서 최적의 가중치를 학습하게 된다.마스크 언어 모델링 태스크는 빈칸채우기 태스크 (cloze task)라고도 한다. 지금까지 마스크 언어 모델링 태스크가 작동하는 방식과 마스크 언어 모델링 태스크를 사용해 BERT를 학습시키는 방법을 배웠다. 이제 좀 더 어려운 전체 단어 마스킹 방법을 알아보자.전체 단어 마스킹(WWM)전체 단어 마스킹 (Whole Word Masking, WWM)이 어떻게 동작하는지 예제를 통해 이해해보자. “Let us start pretraining the model” 이라는 문장을 예로 들어보자. BERT는 워드피스 토크나이저를 사용하므로 워드피스 토크나이저를 통해 문장을 토큰화하면 다음과 같은 토큰을 얻게 된다.tokens = [\"let\", \"us\", \"start\", \"pre\", \"##train\", \"##ing\", \"the\", \"model\"]문장 시작 부분에 [CLS] 토큰을 추가하고 문장 끝부분에 [SEP] 토큰을 추가한다.tokens = [\"[CLS]\", \"let\", \"us\", \"start\", \"pre\", \"##train\", \"##ing\", \"the\", \"model\", \"[SEP]\"]마지막으로 단어의 15%를 무작위로 마스킹하는데, 마스킹 결과가 다음과 같다고 가정해보자.tokens = [\"[CLS]\", \"[MASK]\", \"us\", \"start\", \"pre\", \"[MASK]\", \"##ing\", \"the\", \"model\", \"[SEP]\"]let과 ##train이라는 단어를 마스킹했다. ##train이라는 단어는 하위 단어로 사전 학습이라는 단어의 일부다. WWM 방법에서는 하위 단어가 마스킹되면 해당 하위 단어와 관련된 모든 단어를 마스킹한다. 따라서 이제 토큰 리스트는 다음과 같아진다.tokens = [\"[CLS]\", \"[MASK]\", \"us\", \"start\", \"[MASK]\", \"[MASK]\", \"[MASK]\", \"the\", \"model\", \"[SEP]\"]##train 하위 단어와 관련된 모든 단어들이 마스킹되었다. WWM의 경우 하위 단어가 마스킹되면 하위 단어와 관련된 모든 단어를 마스킹하면서 마스크 비율(15%)을 유지하려 한다. 따라서 하위 단어와 관련된 모든 단어를 마스킹하는 동안 마스킹 비율이 15%를 초과하면 다른 단어의 마스킹을 무시한다. 다음과 같이 마스킹 비율을 유지하기 위해 let의 마스킹을 무시했다.tokens = [\"[CLS]\", \"let\", \"us\", \"start\", \"[MASK]\", \"[MASK]\", \"[MASK]\", \"the\", \"model\", \"[SEP]\"]이러한 방식으로 WWM을 기반으로 토큰을 마스킹한다. 마스킹한 후 토큰을 BERT에 입력하고 앞서 배운 것처럼 마스크된 토큰을 예측하도록 모델을 학습시킨다.다음 문장 예측(NSP)NSP는 BERT학습에 사용되는 또 다른 흥미로운 태스크로, 이진 분류 태스크이다. NSP 태스크에서는 BERT에 두 문장을 입력하고 두 번째 문장이 첫 번째 문장의 다음 문장인지 예측한다. 예제를 통해 NSP 태스크를 이해해보자.다음 두 문장이 주어졌다고 가정해보자. A: She cooked pasta. B: It was delicious.이 문장 쌍에서 B 문장은 A 문장의 후속 문장이다. 즉, A 문장에서 이어지는 문장이다. 따라서 이 문장 쌍을 isNext로 표시해 B 문장이 A 문장의 다음 문장임을 알 수 있게 한다.다시 다음 문장이 주어졌다고 가정해보자. A: Turn the radio on. B: She bought a new hat.이 문장 쌍에서 B 문장은 A 문장의 후속 문장이 아니다. 즉, A 문장에 이어지는 문장이 아니다. 따라서 이 문장 쌍을 notNext로 표시해 B 문장이 A 문장의 다음 문장이 아님을 알 수 있게 한다.NSP 태스크에서 모델의 목표는 문장 쌍이 isNext 범주에 속하는지 여부를 예측하는 것이다. 문장 쌍 (문장 A 및 B)을 BERT에 입력하고 B 문장이 A 문장 다음에 오는지 여부를 예측하도록 학습시킨다. 모델은 B문장이 A문장에 이어지면 isNext를 반환하고, 그렇지 않으면 notNext를 반환한다. 따라서 NSP는 본질적으로 이진 분류 태스크이다.NSP 태스크의 목적은 무엇일까? NSP 태스크를 수행함으로써 모델은 두 문장 사이의 관계를 파악할 수 있다. 두 문장 간의 관계를 이해하는 것은 질문-응답 및 유사문장탐지와 같은 다운스트림 태스크에서 유용하다.그럼, NSP 태스크를 위한 데이터셋을 어떻게 얻을 수 있을까? 어떠한 말뭉치에서도 데이터셋을 확보할 수 있다. 2개의 문서가 있다고 가정해보자. isNext 클래스의 경우 한 문서에서 연속된 두 문장을 isNext로 표시하고 notNext 클래스의 경우 한 문서에서 한 문장을, 임의의 문서에서 다른 문장을 가져와 notNext로 표시하면 된다. isNext 클래스를 전체의 50% 비율로 유지하고 notNext 클래스에서 나머지 50%를 유지해 클래스가 균형을 이룰 수 있도록 한다.이제 NSP 태스크가 무엇인지 알았으니, NSP 태스크를 수행하기 위해 BERT를 학습시키는 방법을 살펴보겠다. 데이터셋이 [그림 2-15]와 같이 나타난다고 가정해보자. 그림 2-15 간단한 데이터셋[그림 2-15]에 제시된 첫 번째 데이터를 살펴보자. 먼저 다음과 같이 문장 쌍을 토큰화한다.tokens = [\"She\", \"cooked\", \"pasta\", \"It\", \"was\", \"delicious\"]첫 번째 문장의 시작 부분에 [CLS] 토큰을 추가하고 모든 문장의 끝에 [SEP] 토큰을 추가한다.tokens = [\"[CLS]\", \"She\", \"cooked\", \"past\", \"[SEP]\", \"it\", \"was\", \"delicious\", \"[SEP]\"]이 토큰들을 토큰, 세그먼트, 위치 임베딩 레이어에 입력하고 입력 임베딩을 반환받는다. 그런 다음 입력 임베딩을 BERT에 넣어 각 토큰의 표현을 얻는다. [그림 2-16]에서 볼 수 있듯 토큰 $R_{CLS}$는 [CLS]의 표현을 나타내고 $R_{she}$는 She 토큰의 표현을 나타낸다. 그림 2-16 BERT좀 전에 NSP가 이진 분류 작업이라고 배웠는데, 지금 우리는 문장 쌍에서 각 토큰의 표현만 가지고 있다. 이러한 표현을 기반으로 문장 쌍을 어떻게 분류할 수 있을까?분류를 수행하려면 간단히 [CLS] 토큰 표현을 가져와 소프트맥스 함수를 사용해 피드포워드 네트워크에 입력한다. 그러면 문장쌍이 isNext인지, notNext인지에 대한 확률값이 반환된다. 그렇다면 왜 [CLS] 토큰만 포함시켜야 할까? 다른 토큰의 임베딩이 아닌 이유는 무엇일까?[CLS] 토큰은 기본적으로 모든 토큰의 집계 표현을 보유하고 있으므로 문장 전체에 대한 표현을 담고 있다. 따라서 다른 모든 토큰의 표현을 무시하고 [CLS] 토큰 표현 $R_{CLS}$를 가져와 확률을 반환하는 소프트맥스 함수를 사용해 피드포워드 네트워크에 공급할 수 있다. 이러한 내용이 [그림 2-17]에 포현되어 있다. 여기서는 복잡함을 줄이기 위해 입력 임베딩 레이어(토큰, 세그먼트, 임베딩 레이어)를 표시하지 않았다. 그림 2-17 NSP 태스크[그림 2-17]의 피드포워드 네트워크는 입력 문장이 isNext 클래스에 속할 확률이 높다는 것을 보여준다.학습 초기에는 피드포워드 네트워크 및 인코더 계층의 가중치가 최적이 아니기 때문에 모델이 올바른 확률을 반환하지 못할 것이다. 그러나 역전파를 기반으로 한 일련의 반복학습을 통해 피드포워드 네트워크의 가중치와 BERT 인코더 계층의 가중치를 업데이트하고 최적의 가중치를 학습하게 된다.2.4.3 사전 학습 절차BERT의 사전 학습에는 토론토 책 말뭉치 및 위키피디아 데이터셋을 사용한다. 앞서 BERT는 MLM 및 NSP 태스크를 사용해 사전 학습된다는 것을 배웠다. 그럼, 이 두 태스크를 사용해 BERT를 학습시키기 위한 데이터셋을 어떻게 준비할까?먼저 말뭉치에서 두 문장을 샘플링한다. A와 B문장을 샘플링했다고 가정해보자. A와 B 문장의 총 토큰 수의 합은 512보다 작거나 같아야 한다. 두 문장을 샘플링할 때 전체의 50%는 B 문장이 A 문장의 후속 문장이 되도록 샘플링하고, 나머지 50%는 B 문장을 A 문장의 후속 문장이 아닌 것으로 샘플링한다.다음 두 문장을 샘플링했다고 가정하자. A 문장: We enjoyed the game. B 문장: Turn the radio on.먼저 워드피스 토크나이저를 통해 문장을 토큰화하고 첫 번째 문장 시작 부분에 [CLS] 토큰을 추가한 다음 모든 문장의 끝에 [SEP] 토큰을 추가해, 다음과 같은 토큰 리스트를 얻는다.tokens = [\"[CLS]\", \"we\", \"enjoyed\", \"the\", \"game\", \"[SEP]\", \"turn\", \"the\", \"radio\", \"on\", \"[SEP]\"]다음 과정으로, 80-10-10% 규칙에 따라 토큰의 15%를 무작위로 마스킹한다. game 토큰을 마스킹했다고 가정하면 다음과 같다.tokens = [\"[CLS]\", \"we\", \"enjoyed\", \"the\", \"[MASK]\", \"[SEP]\", \"turn\", \"the\", \"radio\", \"on\", \"[SEP]\"]이제 토큰을 BERT에 입력하고 마스크된 토큰을 예측하기 위해 모델을 학습시키며 동시에 B 문장이 A 문장의 후속 문장인지 여부를 분류하게 한다. 즉, MLM과 NSP 작업을 동시에 사용해 BERT를 학습시킨다.BERT는 총 100만 스텝을 학습시키고, 각 스텝당 크기 256 입력 시퀀스에 대해 학습시킨다. 학습률은 $lr=1e-4, \\beta_1=0.9, \\beta_2=0.999$로 설정하고 아담 옵티마이저를 사용하며, 웜업은 1만 스텝으로 학습을 진행한다. 여기서 웜업 스텝은 무엇일까?학습이 진행되면, 높은 학습률을 설정해 학습 초기에 모델의 큰 변화를 유도하고 학습 후반에는 낮은 학습률을 설정해 모델에 작은 변화를 주어 최적화한다. 학습 초기에는 수렴과 거리가 멀기 때문에 모델에 과감한 변화를 주지만 이후에는 수렴에 가까워지기 때문에 큰 변화보다 작은 변화를 주어 모델을 최적화 하는 것이다. 이와 같이 학습 초기에 학습률 값을 높게 설정한 다음 학습이 진행되면서 학습률을 감소시키는 것을 학습률 스케줄링이라고 한다.웜업 스텝은 학습률 스케줄링의 일부다. 학습률이 $lr=1e-4$고 웜업 스텝이 총 1만 스텝이라고 가정하면, 초기 1만 스텝은 학습률이 0에서 $1e-4$로 선형적으로 증가한다는 것을 의미한다. 1만 스텝 후에는 수렴에 가까워짐에 따라 학습률을 선형적으로 감소시키게 된다.또한 드롭아웃확률이 0.1인 모든 레이어에 드롭아웃을 적용한다. BERT에서는 GELU라는 활성화 함수를 사용하는데, 이는 가우시안 오차 선형 유닛(Gaussian Error Linear Unit)을 의미한다.GELU 함수는 다음과 같다.\\[GELU(x)=x\\phi(x)\\]$\\phi(x)$는 표준 가우시안 누적 분포(standard Gaussian cummulative distribution)함수이며, GELU 함수는 다음 수식의 근사치다.\\[GELU(x)=0.5x(1+\\tanh(\\sqrt{2\\over\\pi}(x+0.044715x^3)))\\][그림 2-18]은 GELU 함수를 도식화 한 것이다. 그림 2-18 GELU 활성화 함수이게 전부다. 이러한 방식으로 MLM 및 NSP 태스크를 사용해 BERT를 사전 학습시킬 수 있다. 사전 학습된 BERT는 다양한 태스크에 이용할 수 있다." }, { "title": "BERT의 구조", "url": "/posts/bert-structure/", "categories": "NLP, BERT", "tags": "nlp, bert", "date": "2022-09-09 12:30:00 +0900", "snippet": "BERT 논문 저자들은 아래와 같이 두 가지 구성의 모델을 제시했다. BERT-base BERT-large각각을 자세히 알아보자.2.3.1 BERT-baseBERT-base는 12개의 인코더 레이어가 스택처럼 쌓인 형태로 구성되어 있다. 모든 인코더는 12개의 어텐션 헤드를 사용하며, 인코더의 피드포워드 네트워크는 768개 차원의 은닉 유닛으로 구성된다. 따라서 BERT-base에서 얻은 표현의 크기는 768이다.앞으로 다음 표기법을 사용할 것이다. 인코더 레이어의 수는 $L$로 표시할 것이다. 어텐션 헤드는 $A$로 표시한다. 은닉 유닛은 $H$로 표시한다.BERT-base 모델은 $(L, A, H)=(12, 12, 768)$ 가 되며, 총 변수의 수는 1억 1천만 개다. [그림 2-5]는 BERT-base 모델을 시각화 한 것이다. 그림 2-5 BERT-base2.3.2 BERT-largeBERT-large는 24개의 인코더 레이어가 스택처럼 쌓인 형태로 구성되어 있다. 모든 인코더는 16개의 어텐션 헤드를 사용하며, 인코더의 피드포워드 네트워크는 1024개의 은닉 유닛으로 구성된다. 따라서 BERT-large에서 얻은 표현의 크기는 1024가 된다.BERT-large 모델은 $(L, A, H)=(24, 16, 1024)$가 되며, 총 변수의 수는 3억 4천만 개다. [그림 2-6]은 BERT-large 모델을 시각화 한 것이다. 그림 2-6 BERT-large2.3.3 그 밖의 여러 BERT 구조앞의 두 가지 표준 구조 외에도 다른 조합으로 BERT를 구축할 수 있다. 더 작은 구조 중 일부는 다음과 같다. BERT-tiny: $(L, A, H)=(2, 2, 128)$ BERT-mini: $(L, A, H)=(4, 4, 256)$ BERT-small: $(L, A, H)=(4, 8, 521)$ BERT-medium: $(L, A, H)=(8, 8, 521)$컴퓨팅 리소스가 제한된 환경에서는 더 작은 BERT가 적합할 수 있다. 하지만 BERT-base, BERT-large와 같은 표준 구조가 더 정확한 결과를 제공하기 때문에 가장 널리 사용되고 있다." }, { "title": "BERT의 동작 방식", "url": "/posts/bert-act/", "categories": "NLP, BERT", "tags": "nlp, bert", "date": "2022-09-09 12:20:00 +0900", "snippet": "이름에서 알 수 있듯이 BERT는 트랜스포머 모델을 기반으로 하며, 인코더-디코더가 있는 트랜스포머 모델과 달리 인코더만 사용한다.1장에서 문장을 트랜스포머 인코더에 입력하고 문장의 각 단어에 대한 표현 벡터를 출력으로 반환한다는 것을 확인했다. 그럼, 양방향 (Bidirectional)이라는 단어는 무엇을 의미할까?트랜스포머 인코더는 원래 양방향으로 문장을 읽을 수 있기 때문에 양방향이다. 따라서 BERT는 기본적으로 트랜스포머에서 얻은 양방향 인코더 표현이다.예제를 통해 BERT가 어떻게 트랜스포머에서 양방향 인코더 표현을 하는지 이전 절에서 살펴본 문장으로 이해해보자.“He got bit by Python” 이라는 문장 A를 트랜스포머에 입력으로 제공하고 문장의 각 단어에 대한 문맥 표현 (임베딩)을 출력으로 가져온다. 인코더에 문장을 입력하면 인코더는 멀티 헤드 어텐션 메커니즘을 사용해 문장의 각 단어의 문맥을 이해해 문장에 있는 각 단어의 문맥 표현을 출력으로 반환한다.[그림 2-3]과 같이 문장을 트랜스포머 인코더에 입력으로 제공하고 문장의 각 단어를 출력으로 표시했다. 그림과 같이 N개의 인코더를 쌓을 수 있으나, 불필요한 복잡함을 줄이기 위해 하나의 블록만 확장했다. [그림 2-3]에서 “파이썬”이라는 단어의 표현을 출력하고 차례로 “그(the)”라는 단어의 표현을 출력한다. 각 토큰의 표현 크기는 인코더 레이어의 출력의 차원이며, 인코더 레이어의 차원이 768이라고 가정하면 각 토큰의 표현 크기는 768이 된다. 그림 2-3 BERT에 입력된 A 문장의 각 단어 표현 출력마찬가지로 , “Python is my favorite programming language”라는 B 문장을 트랜스포머 인코더에 입력하면 그[그림 2-4]와 같이 문장의 각 단어에 대한 문맥 표현을 얻을 수 있다. 그림 2-4 BERT에 입력된 B 문장의 각 단어 표현 출력" }, { "title": "BERT의 기본 개념", "url": "/posts/bert-basic/", "categories": "NLP, BERT", "tags": "nlp, bert", "date": "2022-09-09 12:10:00 +0900", "snippet": "BERT (Bidirectional Encoder Representation from Transformer)는 구글에서 발표한 최신 임베딩 모델이다. 질문에 대한 대답, 텍스트 생성, 문장 분류 등과 같은 태스크에서 가장 좋은 성능을 도출해 자연어 처리 분야에 크게 기여했다. BERT가 성공한 주된 이유는 문맥이 없는 워드투벡터와 같은 다른 인기 있는 임베딩 모델과 달리 문맥을 고려한 임베딩 모델이기 때문이다.먼저 다음 두 문장을 통해 문맥 기반 임베딩 모델과 문맥 독립 임베딩 모델의 차이를 이해해 보자. A 문장: He got bit by Pythob (파이썬이 그를 물었다.) B 문장: Python is my favorite programming language (내가 가장 좋아하는 프로그래밍 언어는 파이썬이다).두 문장에서 “파이썬” 이라는 단어의 의미가 서로 다르다는 것을 알 수 있다. A 문장에서 “파이썬”이라는 단어는 뱀의 한 종류를 의미하고 B 문장에서 “파이썬”이라는 단어는 프로그래밍 언어를 의미한다.워드투벡터와 같은 임베딩 모델을 사용해 앞의 두 문장에서 “파이썬” 이라는 단어에 대한 임베딩을 얻는 경우 두 문장에서 동일한 단어가 쓰였으므로 동일하게 표현하게 된다. 이는 워드투벡터가 문맥 독립 모델이기 때문에 문맥과 관계없이 “파이썬”이라는 단어에 대해 항상 동일한 임베딩을 제공하기 때문이다.반면 BERT는 문맥기반모델이므로 문장의 문맥을 이해한 다음 문맥에 따라 단어 임베딩을 생성한다. 따라서 앞의 두 문장의 문맥을 기반으로 “파이썬”이라는 단어에 대해 서로 다른 임베딩을 제공한다. 그런데 BERT는 어떻게 작동하는 것일까? 문맥을 어떻게 이해할까? 이에 대해 더 자세히 살펴보자.A 문장 ( He got bit by Python)을 보자. BERT는 모든 단어와 문맥상 의미를 이해하기 위해 문장의 각 단어를 문장의 다른 모든 단어와 연결시켜 이해한다. 따라서 “파이썬”이라는 단어와 문맥상 의미를 이해하기 위해 문장의 다른 모든 단어와 관계를 기반으로 이해하려 시도한다. 이렇게 하면 BERT는 A 문장의 “파이썬”이라는 단어와 “물었다”라는 단어의 강한 연결 관계를 파악해 “파이썬”이 뱀의 한 종류를 의미한다는 것을 파악하게 된다. 그림 2-1 파이썬과 다른 모든 단어의 관계이제 B 문장 (Python is my favorite programming language)을 보자. 마찬가지로 여기서 BERT는 모든 단어의 문맥상 의미를 이해하기 위해 문장의 각 단어를 문장의 모든 단어와 연결한다. 따라서 BERT는 “파이썬”이라는 단어를 가져와서 이 단어의 의미를 이해하기 위해 문장의 모든 단어와 연결한다. 이렇게 함으로써 BERT는 B문장의 “파이썬”이라는 단어가 “프로그래밍” 이라는 단어와 함께 사용되고 있으므로 프로그래밍 언어와 관련이 있음을 인지하게 된다. 그림 2-2 파이썬과 다른 모든 단어의 관계문맥 독립 모델과 달리 문맥과 관계 없이 정적 임베딩을 생성하는 워드투벡터와 달리 BERT는 문맥을 기반으로 동적 임베딩을 생성한다." }, { "title": "트랜스포머-인코더 디코더 결합", "url": "/posts/transformer-endecoder/", "categories": "NLP, TRANSFORMER", "tags": "nlp, transformer, encoder, decoder", "date": "2022-09-09 12:00:00 +0900", "snippet": "인코더와 디코더를 포함한 완전한 모양의 트랜스포머 아키텍처는 다음과 같다. 그림 1-63 트랜스포머 인코더, 디코더$N \\times$ 는 인코더와 디코더를 $N$개 쌓을 수 있음으로 나타낸다. [그림 1-63]에서 알 수 있듯이, 입력 문장 (소스 문장)을 입력하면 인코더에서는 해당 문장에 대한 표현을 학습시키고, 그 결괏값을 디코더에 보내면 디코더에서 타깃 문장을 생성한다.1.5 트랜스포머 학습손실 함수 (loss function)을 최소화하는 방향으로 트랜스포머 네트워크를 학습시킬 수 있다. 이때 어떤 손실 함수를 사용해야 할까? 디코더가 vocab에 대한 확률 분포를 예측하고 확률이 가장 큰 단어를 선택한다는 것을 배웠다. 즉, 올바른 문장을 생성하려면 예측 확률 분포와 실제 확률 분포 사이의 차이를 최소화해야 한다. 그러려면 두 분포의 차이를 알아야 한다. 이때 교차 엔트로피 (cross entropy)를 사용하면 분포의 차이를 알 수 있다. 따라서 손실 함수를 교차 엔트로피 손실 (cross-entropy loss)로 정의하고 예측 확률 분포와 실제 확률 분포를 최소화하도록 모델을 학습한다. 이때 옵티마이저 (optimizer)는 아담 (Adam)을 사용한다.여기서 한 가지 고려할 점은 overfitting을 방지하려면 각 서브레이어의 출력에 드롭아웃을 적용하고, 임베딩 및 위치 인코딩의 합을 구할 때도 드롭아웃을 적용해야 한다는 것이다.1.6 마치며이번 장에서는 트랜스포머 모델이 무엇인지, 인코더-디코더 아키텍처가 어떤 원리로 작동하는지를 다뤘다. 트랜스포머의 인코더 부분을 살펴보면서 멀티 헤드 어텐션과 피드 포워드 네트워크 같은 인코더에서 사용하는 다양한 서브레이어를 확인했다.셀프 어텐션은 단어를 좀 더 잘 이해하기 위해 주어진 문장의 모든 단어와 해당 단어를 연결하는 형태다. 셀프 어텐션을 계산하기 위해 쿼리, 키, 밸류 행렬이라는 세 가지 행렬을 사용했다. 그 다음으로 위치 인코딩을 계산하는 방법과 위치 인코딩을 사용해 문장 내 단어의 순서를 입력하는 방법도 살펴봤다. 인코더에서 피드포워드 네트워크가 작동하는 방법과 add 및 norm 요소에 대해서도 배웠다.인코더에 대해 알아본 다음 디코더의 작동 원리를 살펴봤다. 마스크된 멀티 헤드 어텐션, 인코더-디코더 어텐션, 피드포워드 네트워크 등 디코더에서 사용하는 서브레이어를 알아봤다. 트랜스포머의 인코더와 디코더가 결합한 형태에서 어떻게 작동하는지 이해한 다음 네트워크를 학습시키는 방법도 배웠다." }, { "title": "트랜스포머-디코더", "url": "/posts/transformer-decoder/", "categories": "NLP, TRANSFORMER", "tags": "nlp, transformer, decoder", "date": "2022-09-09 11:00:00 +0900", "snippet": "영어 “I am good”을 입력하면 프랑스어 “Je vais bien”을 생성하는 번역기를 만든다고 가정하자. 번역기를 만들려면 먼저 입력 문장인 “I am good”을 인코더에 입력해야 한다. 인코더는 입력 문장의 표현을 학습한다. 앞에서 인코더가 입력 문장을 학습하는 방법을 상세히 다뤘다. 이제 이 인코더의 결괏값을 가져와서 디코더에 입력값으로 사용한다. 디코더는 다음 그림과 같이 인코더의 표현을 입력값으로 사용하고 타깃 문장인 “Je vais bein”을 생성한다. 그림 1-35 트랜스포머의 인코더와 디코더인코더 부분을 다룰 때 인코더 $N$개를 누적해서 쌓을 수 있다는 것을 배웠다. 인코더와 유사하게 디코더 역시 $N$개를 누적해서 쌓을 수 있다. $N=2$로 예를 들어보자. [그림 1-36]에 표시된 것처럼 하나의 디코더 출력값은 그 위에 있는 디코더의 입력값으로 전송된다. 또한 인코더의 입력 문장 표현 (인코더의 출력값)이 모든 디코더에 전송된다. 즉, 디코더는 이전 디코더의 입력값과 인코더의 표현(인코더의 출력값), 이렇게 2개를 입력 데이터로 받는다. 그림 1-37 시간 스텝 t=1 경우 디코더 예측시간 스텝 t=2 경우 현재까지의 입력값에 이전 단계 (t-1) 디코더에서 생성한 단어를 추가해 문장의 다음 단어를 생성한다. 즉 [그림 1-38]처럼 디코더는 &lt;sos&gt;와 “Je”를 입력받아 타깃 문장의 다음 단어를 생성한다. 그림 1-38 시간 스텝 t=2 경우 디코더 예측위의 방법과 마찬가지로 모든 단계에서 디코더는 이전 단계에서 새로 생성한 단어를 조합해 입력값을 생성하고 다음 단어를 예측하는 방법을 진행한다. 따라서 $t=4$의 경우 &lt;sos&gt;, “Je”, “vais”, “bien”을 입력하고 다음 단어를 예측한다. 그림 1-39 시간 스텝 t=4 경우 디코더 예측[그림 1-40]을 통해 알 수있듯이 디코더에서 &lt;eos&gt; 토큰을 생성할 때 타깃 문장의 생성이 완료된다.인코더의 경우, 입력 문장을 임베딩 행렬로 변환한 후 여기에 위치 인코딩을 더한 값을 입력한다. 마찬가지로 디코더 역시 입력값을 바로 입력하는 것이 아니라 위치 인코딩을 추가한 값을 디코더의 입력값으로 사용한다.예를 들어 [그림 1-41]처럼 각 시간 단계의 입력을 임베딩으로 변환한다고 할 때 위치 인코딩 값을 추가한 다음 디코더에 입력한다. 그림 1-41 위치 인코딩이 적용된 인코더와 디코더하나의 디코더 블록은 다음과 같은 요소들로 구성된다. 그림 1-42 디코더 블록디코더 블록은 서브레이어 3개로 구성된 인코더 블록과 유사한 구조다. 마스크된 멀티 헤드 어텐션 (masked multi-head attention) 멀티 헤드 어텐션 (multi-head attention) 피드포워드 네트워크 (feedforward network)디코더 블록은 인코더 블록과 유사하게 서브레이어에 멀티 헤드 어텐션과 피드포워드 네트워크를 포함한다. 하지만 인코더와 다르게 두 가지 형태의 멀티 헤드 어텐션을 사용한다. 그 중 하나는 어텐션 부분인 마스크된 형태이다.1.3.1 마스크된 멀티 헤드 어텐션영어를 프랑스어로 번역하는 태스크가 있고, 학습 데이터가 다음과 같이 준비되어 있다고 가정하자. 그림 1-43 학습 데이터 예제위의 데이터를 통해 번역 태스크의 입력과 출력 형태를 이해할 수 있다. 앞에서 번역 모델에 대한 테스트를 수행할 때 디코더에서 타깃 문장을 어떻게 생성하는지 알아봤다.모델을 학습할 때는 이미 타깃 문장을 알고 있어서 디코더에 기본으로 타깃 문장 전체를 입력하면 되지만 수정 작업이 조금 필요하다. 디코더에서 문장을 입력할 때 처음에는 &lt;sos&gt; 토큰을 입력하고 &lt;eos&gt; 토큰이 생성될 때까지 이전 단계에서 예측한 단어를 추가하는 형태로 입력을 반복한다. 따라서 타깃 문장의 시작 부분에 &lt;sos&gt; 토큰을 추가한 다음 디코더에 입력한다.“I am good”을 “Je vais bien”으로 번역한다고 가정해보자. 타깃 문장 시작 부분에 &lt;sos&gt; 토큰을 추가한 “&lt;sos&gt; je vais bien”을 디코더에 입력하면 디코더에서 “Je vais bien &lt;eos&gt;”를 출력한다. 그림 1-44 트랜스포머의 인코더, 디코더그렇다면 세부적으로 어떤 방식으로 작동하는 것인가? 왜 타깃 문장 전체를 입력하고 디코더에서는 한 단계 이동한 형태의 문장을 출력하는 것인가? 이 부분을 좀 더 자세히 알아보자.디코더에 입력 문장을 입력할 때 입력 문장을 임베딩 (출력 임베딩 행렬)으로 변환한 후 위치 인코딩을 추가해 디코더에 입력하는 것은 알고 있다. 디코더의 입력 행렬을 $X$라고 하자. 그림 1-45 입력 행렬행렬 $X$를 디코더에 입력하면 첫 번째 레이어는 마스크된 멀티 헤드 어텐션이 된다. 인코더에서 사용한 멀티 헤드 어텐션과 기본 원리는 같지만 다른 점이 한 가지 있다.셀프 어텐션을 구현하면 처음에 $Q, K, V$행렬을 생성한다.멀티 헤드 어텐션을 계산하면 $h$개의 $Q, K, V$행렬을 생성한다. 헤드 $i$의 경우 행렬 $X$에 각각 가중치 행렬 $w_i^Q, w_i^K, w_i^V$를 곱해 $Q_i, K_i, V_i$ 행렬을 얻을 수 있다.이제 마스크된 멀티 헤드 어텐션을 살펴보자. 디코더의 입력 문장은 ‘&lt;sos&gt; Je vais bein”이다. 앞에서 셀프 어텐션은 각 단어의 의미를 이해하기 위해 각 단어와 문장 내 전체 단어를 연결했다. 그런데 디코더에서 문장을 생성할 때 이전 단계에서 생성한 단어만 입력문장으로 넣는다는 점이 중요하다. 예를 들어 $t=2$의 경우 디코더의 입력 단어는 [&lt;sos&gt;, Je]만 들어간다.즉, 이런 데이터의 특성을 살려 모델 학습을 진행해야 한다. 따라서 셀프 어텐션은 단어와의 연관성을 “Je”만 고려해야 하며, 모델이 아직 예측하지 않은 오른쪽의 모든 단어를 마스킹해 학습을 진행한다. 그림 1-46 값에 대한 마스킹 처리이와 같은 단어 마스킹 작업은 셀프 어텐션에서 입력되는 단어에만 집중해 단어를 정확하게 생성하는 긍정적인 효과를 가져온다. 그렇다면 마스킹을 어떻게 수현할 수 있을까? $i$ 헤드의 어텐션 행렬 $Z_i$는 다음 식으로 구할 수 있다.\\[Z_i=softmax({QK^T\\over\\sqrt{d_k}})V_i\\]어텐션 행렬을 구하는 첫 번째 단계는 쿼리와 키 행렬 사이의 내적을 계산하는 것이다. [그림 1-48]은 쿼리와 키 행렬 사이의 내적값을 구하고, $\\sqrt{d_k}$로 나눈 임의의 결과다. 그림 1-48위 행렬에 소프트맥스 함수를 적용해 정규화 작업을 수행한다. 소프트맥스 함수를 적용하기 전에 행렬값에 대한 마스킹 처리가 필요하다. 예를 들어 위 행렬의 첫 번째 행을 보자. &lt;sos&gt;의 다음 단어를 예측한다고 할 때 모델에서는 &lt;sos&gt; 오른쪽에 있는 모든 단어를 참조하지 말아야한다. &lt;sos&gt; 오른쪽에 있는 모든 단어를 $-\\infty$로 마스킹한다. 두 번째, 세 번째 행도 마찬가지로 수행한다. 이제 소프트맥스 함수를 적용한 행렬과 밸류 $(V_i)$ 행렬에 곱해 최종적으로 어텐션 행렬 $Z_i$를 구한다. 멀티 헤드 어텐션의 경우 $h$개의 어텐션 행렬을 구하고 이들을 서로 연결한 후에 새로운 가중치 행렬 $W^0$을 곱해 최종적으로 어텐션 행렬 $M$을 구한다.\\[M=concatenate(Z_1, Z_2, Z_3, \\cdots, Z_h)W_0\\]1.3.2 멀티 헤드 어텐션[그림 1-52]는 인코더와 디코더를 결합한 트랜스포머 모델의 모습이다. 이때 디코더의 멀티 헤드 어텐션은 입력 데이터 2개를 받는다. 하나는 이전 서브레이어의 출력값이고, 다른 하나는 인코더의 표현이다. 그림 1-52 인코더와 디코더 상호 작용인코더의 표현 값을 $R$, 이전 서브레이어인 마스크된 멀티 헤드 어텐션의 결과로 나온 어텐션 행렬을 $M$이라고 한다. 여기서 인코더의 결과와 디코더의 결과 사이에 상호 작용이 일어난다. 이를 인코더-디코더 어텐션 레이어 (encoder-decoder attention layer)라고 한다.이제 멀티 헤드 어텐션 레이어가 어떻게 작동하는지 알아보자. 첫 번째 단계에서는 멀티 헤드 어텐션에서 사용하는 쿼리, 키, 밸류 행렬을 생성한다. 앞에서 행렬에 가중치 행렬을 곱해서 쿼리, 키, 밸류 행렬을 만들 수 있다는 것을 배웠다. 하지만 이번에는 입력값이 2개 (인코더 표현 $R$, 이전 서브레이어의 결과인 $M$)다. 이런 경우에는 어떻게 해야 할까?이전 서브레이어의 출력값인 어텐션 행렬 $M$을 사용해 쿼리 행렬 $Q$를 생성하고, 인코더 표현 값인 $R$을 활용해 $K, V$행렬을 생성한다. 현재 멀티 헤드 어텐션을 사용하고 있으므로 헤드 $i$를 기준으로 다음 절차를 따른다. 어텐션 행렬 $M$에 가중치 행렬 $W_i^Q$를 곱해 쿼리 행렬 $Q_i$를 생성한다. 인코더 표현값 $R$에 가중치 행렬 $W_i^K, W_i^V$를 각각 곱해 키, 밸류 행렬 $K_i, V_i$를 생성한다. 그림 1-53 쿼리, 키, 밸류 행렬 생성왜 쿼리 행렬은 $M$을 통해 생성하고 키, 밸류 행렬은 $R$을 통해 생성하는 것일까? 일반적으로 쿼리 행렬은 타깃 문장의 표현을 포함하므로 타깃 문장에 대한 값인 $M$의 값을 참조한다. 키와 밸류 행렬은 입력 문장의 표현을 가져서 $R$의 값을 참조한다. 이때 장점은 무엇일까? 셀프 어텐션을 단계적으로 계산하면서 좀 더 자세히 알아보자.셀프 어텐션의 첫 번째 단계는 쿼리, 키 행렬 간의 내적을 계산하는 것이다. 앞에서 설명했듯이 쿼리 행렬은 $M$의 값을, 키 행렬은 $R$의 값을 참조했다. 쿼리 , 키 행렬값은 다음 그림과 같다. 위 행렬 $Q_i\\cdot K_i^T$를 통해 다음 사실을 이해할 수 있다. 행렬의 첫 번째 행에서 쿼리 벡터 $q_1(&lt;sos&gt;)$와 모든 키 벡터 $k_1(I), k_2(am), k_3(good)$ 사이의 내적을 계산한다. 첫 행은 타깃 단어 $&lt;sos&gt;$가 입력 문장의 모든 단어 (I, am, good)와 얼마나 유사한지를 계산하는 것으로 해석할 수 있다.멀티 헤드 어텐션의 다음 단계는 $Q_i\\cdot K_i^T$를 $\\sqrt{d_k}$로 나누는 것이다. 이후 소프트맥스 함수를 적용하면 스코어 행렬을 얻을 수 있다.\\[Z_i=softmax({Q_iK_i^T\\over \\sqrt{d_k}})V_i\\]어텐션 행렬은 다음 그림처럼 표현할 수 있다. 타깃 문장의 어텐션 행렬 $Z_i$의 경우 각 스코어에 대한 가중치를 반영한 벡터값의 합으로 계산된다. 예를 들어 단어 “Je”, $Z_2$의 셀프 벡터값을 계산한다고 가정하자.\\[Z_2=0.98 \\cdot V_1(I)+0.02 \\cdot V_2(am)+0.0\\cdot V_3(good)\\]이와 유사하게 $h$개의 헤드에 대해 어텐션 행렬을 구한 후 이를 연결하고, 가중치 행렬 $W_0$을 곱하면 최종 어텐션 행렬을 구할 수 있다.\\[multi head \\ attention = concatenate(Z_1, Z_2, \\cdots, Z_h)W_0\\]1.3.3 피드포워드 네트워크다음 그림 처럼 디코더의 다음 서브레이어는 feedforward network이다. 디코더의 피드포워드 네트워크는 앞에서 배운 인코더의 피드포워드 네트워크와 동일한 구조다. 이제 add와 norm에 대해 알아보자.1.3.4 add와 norm 요소인코더에서 배운 것처럼 add와 norm 구성 요소는 [그림 1-60]처럼 서브레이어의 입력과 출력을 서로 연결한다. 그림 1-60 add와 norm 요소가 있는 디코더 블록1.3.5 선형과 소프트맥스 레이어디코더가 타깃 문장에 대한 표현을 학습시키면 [그림 1-61] 처럼 최상위 디코더에서 얻은 출력값을 선형 및 소프트맥스 레이어에 전달한다. 그림 1-61 선형 및 소프트맥스 레이어선형 레이어의 경우 그 크기가 어휘(vocabulary) (이하 vocab) 크기와 같은 logit 형태이다. vocab이 다음과 같이 3개의 요소로 구성되어 있다고 가정하자.\\[vocabulary=[bien, Je, vais]\\]선형 레이어가 반환하는 로짓은 크기가 3인 벡터 형태가 된다. 소프트맥스 함수를 사용해 로짓값을 확률값으로 변환한 다음, 디코더에서 가장 높은 확률값을 갖는 인덱스의 단어로 출력한다. 다음 예제를 통해 더 자세히 알아보자.디코더의 입력 단어가 $&lt;sos&gt;$와 $Je$ 라고 할 때 디코더는 입력 단어를 보고 다음 단어를 예측한다. 이를 위해 디코더에서는 최상위 출력값을 가져와서 선형 레이어에 입력한다. 이 선형 레이어에서 vocab 크기와 동일한 크기의 로짓 벡터를 생성한다. 이 로짓값이 다음과 같다고 가정하자.\\[logit=[45,40,49]\\]이 로짓값에 소프트맥스 함수를 적용하고 확률값 $prob$을 얻는다.\\[prob=[0.0179, 0.000, 0.981]\\]앞의 행렬에서 인덱스가 2인 경우 확률값은 $0.981$로 가장 높다. 따라서 vocab엣서 인덱스가 2인 $vais$가 타깃 문장의 다음 단어로 예측된다. 이런 방식으로 디코더는 타깃 문장의 다음 단어를 예측한다.1.3.6 디코더 모든 구성 요소 연결하기다음 그림은 디코더가 2개 쌓인 형태다. 간결하게 표현하기 위해 디코더의 첫 번째 부분만 확장해서 표현했다. 그림 1-62 디코더 2개가 쌓인 형태[그림 1-62]에서 다음 사실을 알 수 있다. 먼저 디코더에 대한 입력 문장을 임베딩 행렬로 변환한 다음 위치 인코딩 정보를 추가하고 디코더(디코더 1)에 입력한다. 디코더는 입력을 가져와서 마스크된 멀티 헤드 어텐션 레이어에 보내고, 출력으로 어텐션 행렬 $M$을 반환한다. 어텐션 행렬 $M$, 인코딩 표현 $R$을 입력받아 멀티 헤드 어텐션 레이어 (인코더-디코더 어텐션 레이어)에 값을 입력하고, 출력으로 새로운 어텐션 행렬을 생성한다. 인코더-디코더 어텐션 레이어에서 출력한 어텐션 행렬을 다음 서브레이어인 피드포워드 네트워크에 입력한다. 피드포워드 네트워크에서는 이 입력값을 받아서 디코더의 표현으로 값을 출력한다. 디코더 1의 출력값을 디코더 2의 입력값으로 사용한다. 디코더2는 디코더 1에서 수행한 프로세스와 동일한 형태를 진행하고, 타깃 문장에 대한 디코더 표현을 반환한다.디코더의 경우 $N$개의 디코더를 쌓을 수 있다. 이때 최종 디코더 (최상위 디코더)에서 얻은 출력 (디코더 표현)은 타깃 문장의 표현이 된다. 다음으로 타깃 문장의 디코더 표현을 선형 및 소프트맥스 레이어에 입력하고 최종으로 예측된 단어를 얻는다." }, { "title": "트랜스포머-인코더", "url": "/posts/transformer-encoder/", "categories": "NLP, TRANSFORMER", "tags": "nlp, transformer, encoder", "date": "2022-09-09 10:30:00 +0900", "snippet": "트랜스포머는 자연어 처리에서 주로 사용하는 딥러닝 아키텍처 중 하나다. 트랜스포머가 추현한 뒤로, 다양한 태스크에 활용되었던 순환신경망(RNN)과 장단기 메모리(LSTM)는 트랜스포머로 대체된다. BERT, GPT, T5 등과 같은 다양한 자연어 처리(NLP)모델에 트랜스포머 아키텍처가 적용됐다.이번 장에서는 트랜스포머의 기본적인 의미부터 이해해볼 것이다. 그 다음으로 언어 번역 태스크를 통해 인코더-디코더 형태로 어떻게 사용되는지 배운다. 이후에는 각 인코더의 구성요소가 어떻게 동작하는지 자세히 짚어볼 예정이다. 인코더에 대한 전반적인 내용을 다룬 다음 디코더를 살펴보고 디코더의 각 구성요소가 어떻게 작동하는지 알아본다. 마지막으로 인코더와 디코더를 결합해 트랜스포머의 전체 작동 흐름을 확인하자.1.1 트랜스포머 소개RNN과 LSTM 네트워크는 다음 단어 예측, 기계 번역, 텍스트 생성 등의 순차적 태스크에서 널리 사용된다. 하지만 이 네트워크는 장기 의존성 문제가 있다. 이런 RNN의 한계점을 극복하려고 “Attention Is All You Need”논문에서 “트랜스포머”라는 아키텍처를 제안한다. 트랜스포머는 현재 자연어 과제에서 최신 기술로 사용된다. 트랜스포머가 출현함으로써 자연어 처리 분야는 획기적으로 발전했으며 BERT, GPT-3, T5 등과 같은 혁명적인 아키텍처가 발전하는 기반이 마련되었다.트랜스포머는 RNN에서 사용한 순환방식을 사용하지 않고 순수하게 어텐션만 사용한 모델이다. 트랜스포머는 self attention이라는 특수한 형태의 어텐션을 사용한다. 다음 절에서 셀프어텐션이 어떻게 작동하는지 자세히 다룬다.기계번역 과제를 통해 트랜스포머가 어떤 원리로 작동하는지 살펴보자. 트랜스포머는 인코더-디코더로 구성된 모델이다. 먼저 인코더에 입력 문장 (원문)을 입력하면 인코더는 입력 문장의 표현 방법을 학습시키고 그 결과를 디코더로 보낸다. 디코더는 인코더에서 학습한 표현 결과를 입력받아 사용자가 원하는 문장을 생성 한다. 그림 1-1 트랜스포머의 인코더-디코더 구조어떻게 작동하는 것일까? 트랜스포머의 인코더-디코더는 영어 문장 (입력 문장)을 어떻게 프랑스어 문장(타깃 문장)으로 변형하는 것일까? 인코더와 디코더는 어떤 원리로 작동할까? 인코더와 디코더를 자세히 알아보자.1.2 트랜스포머의 인코더 이해하기트랜스포머는 N개의 인코더가 쌓인형태다. 인코더의 결괏값은 그 다음 인코더의 입력값으로 들어간다. [그림 1-2]는 인코더가 N개로 쌓인 형태를 보여준다. 각 인코더의 결괏값은 그 위에 있는 인코더의 입력값으로 들어간다. 가장 마지막에 있는 인코더의 결괏값이 입력값의 최종 표현 결과가 된다. 최초 인코더에 대한 입력값으로 입력 문장을 넣게 되고, 최종 인코더의 결괏값으로 입력 문장에 따르는 표현 결과를 얻는다. 그림 1-2 N개로 누적된 인코더트랜스포머 관련 논문인 “Attention Is All You Need”를 보면 $N=6$으로 되어있다. 이는 인코더 6개를 누적해서 쌓아 올린 형태를 표현한 것이다. 하지만 $N$을 다양한 값으로 지정해 인코더의 형태를 바꿀 수있다. 예를 들어 $N=2$인 경우는 다음과 같이 표현한다. 그림 1-3 N=2 인코더인코더는 어떤 원리로 작동할까? 입력 문장으로 어떤 결괏값을 생성하는가? 이를 이해하려면 우선 인코더의 각 구성요소를 이해해야 한다. 인코더의 세부 구성 요소를 표현하면 다음과 같다. 그림 1-4 인코더의 구성 요소인코더의 구성 요소를 보면 모든 인코더 블록은 형태가 동일하다. 또한 인코더 블록은 두 가지 요소로 구성된다. 멀티 헤드 어텐션 (multi-head attention) 피드포워드 네트워크 (feedforward network)두 가지 요소가 어떻게 작동하는지 자세히 알아보자. 멀티 헤드 어텐션을 이해하려면 먼저 셀프 어텐션이 어떤 원리로 작동하는지 이해해야 한다. 셀프 어텐션의 작동 원리에 대해 살펴보도록 하자.1.2.1 셀프 어텐션의 작동 원리예제를 활용해 셀프 어텐션의 작동 원리를 이해해보자. 다음과 같은 문장이 있다고 가정한다. A dog ate the food because it was hungry.이 문장에서 ‘it’은 ‘dog’나 ‘food’를 의미할 수 있다. 하지만 문장을 자세히 살펴보면 ‘it’은 ‘food’가 아닌 ‘dog’를 의미한다는 것을 쉽게 알 수 있다. 위와 같은 문장이 주어질 경우 모델은 ‘it’이 ‘food’가 아닌 ‘dog’라는 것을 어떻게 알 수 있을까? 이때 셀프 어텐션이 필요하다.이 문장이 입력되었을 때, 모델은 가장 먼저 단어 ‘A’의 표현을, 그 다음으로 단어 ‘dog’의 표현을 계산한 다음 ‘ate’라는 단어의 표현을 계산한다. 각각의 단어를 계산하는 동안 각 단어의 표현들은 문장 안에 있는 다른 모든 단어의 표현과 연결해 단어가 문장 내에서 갖는 의미를 이해한다.예를 들어 ‘it’이라는 단어의 표현을 계산하는 동안 모델에서는 ‘it’이라는 단어의 의미를 이해하기 위해 문장 안에 있는 모든 단어와 ‘it’이라는 단어를 연결하는 작업을 수행한다.[그림 1-5]는 ‘it’이라는 단어의 표현을 계산하기 위해 ‘it’을 문장의 모든 단어와 연결하는 작업을 보여준다. 이와 같은 연결 작업으로 모델은 ‘it’이 ‘food’가 아닌 ‘dog’와 관련이 있다는 것을 학습한다. ‘dog’를 잇는 선이 다른 단어보다 두껍게 표시되었다. 이는 주어진 문장 내에서 ‘it’이라는 단어가 ‘food’가 아닌 ‘dog’와 관련이 있다는 것을 보여준다. 그림 1-5 셀프 어탠션 예제셀프 어텐션은 내부적으로 어떤 원리로 작동할까? 이제 셀프 어텐션 내부 작동 원리를 자세히 알아보자.입력 문장이 ‘I am good’이라고 가정해보자. 이 문장을 기준으로 각 단어의 임베딩을 추출한다. 여기서 임베딩이란 각각의 단어를 표현하는 벡터값을 의미하며, 임베딩값은 모델 학습 과정에서 같이 학습된다.$x_1$ 을 ‘I’, $x_2$를 ‘am’, $x_3$를 ‘good’에 대한 임베딩값이라고 하자. 각각의 값을 표현하면 다음과 같다. 단어 ‘I’에 대한 임베딩: $x_1=[1.76, \\ 2.22, \\ \\cdots, \\ 6.66]$ 단어 ‘am’에 대한 임베딩: $x_2=[7.77, \\ 0.631, \\ \\cdots, \\ 5.35]$ 단어 ‘good’에 대한 임베딩: $x_3=[11.44, \\ 10.10, \\ \\cdots, \\ 3.33]$이제 입력 문장 “I am good”을 [그림 1-6]과 같이 입력 행렬 $X$(임베딩 행렬 또는 입력 임베딩)로 표현할 수 있다.이 입력 행렬 $X$(임베딩 행렬 또는 입력 임베딩)로 표현할 수 있다. 그림 1-6 입력 행렬행렬 $X$에서 첫 번째 행은 ‘I’의 임베딩, 두 번째 행은 ‘am’의 임베딩, 세 번째 행은 ‘good’의 임베딩을 의미한다. 이때 행렬 $X$의 차원은 [문장 길이 x 임베딩 차원]의 형태가 된다. 위 문장에서 단어의 수(문장의 길이)는 3이고 임베딩 차원은 512라고 가정하면 입력 행렬 (입력 임베딩)의 차원은 [3 x 512]가 된다.이제 입력 행렬 $X$로 부터 쿼리 $Q$ 행렬, 키 $K$ 행렬, 밸류 $V$ 행렬을 생성한다. 이 행렬은 무엇이고, 왜 필요할까? 이 세가지 행렬은 셀프 어텐션에서 사용된다. 이 행렬들을 어떻게 사용하는지 살펴보자.우선 쿼리, 키, 밸류 행렬을 어떻게 만드는지 알아보자. 행렬을 생성하기 위해서는 $W^Q, W^K, W^V$라는 3개의 가중치 행렬을 생성한 다음 이 가중치 행렬을 입력행력 $X$에 곱해 $Q, K,V$를 생성한다.이때 가중치 행렬 $W^Q, W^K, W^V$는 처음에 임의의 값을 가지며, 학습 과정에서 최적값을 얻는다. 학습을 통해 최적의 가중치 행렬값이 생성되면 더욱 정확한 쿼리값, 키값, 밸류값을 얻게 된다.[그림1-7]에서 볼 수 있듯이 입력 행렬값에서 가중치 행렬 $W^Q, W^K, W^V$를 곱하면 쿼리, 키, 밸류값을 얻을 수 있다. 그림 1-7 쿼리, 키, 밸류 행렬 생성[그림 1-7]을 통해 다음과 같은 내용을 알 수 있다. 쿼리, 키, 밸류의 첫 번째 행인 $q_1,k_1, v_1$은 단어 ‘I’에 대한 쿼리, 키, 밸류 벡터를 의미한다. 쿼리, 키, 밸류의 첫 번째 행인 $q_2,k_2, v_2$은 단어 ‘am’에 대한 쿼리, 키, 밸류 벡터를 의미한다. 쿼리, 키, 밸류의 첫 번째 행인 $q_3,k_3, v_3$은 단어 ‘good’에 대한 쿼리, 키, 밸류 벡터를 의미한다.이때 쿼리, 키, 밸류 벡터의 차원이 64라고 가정하면 쿼리, 키, 밸류 행렬의 차원은 [문장 길이 x 64] 가 된다. 예제 문장의 세 가지 단어에 대한 쿼리, 키, 밸류 행렬의 차원은 [3 x 64]가 된다.그런데 왜 이런 형태로 계산해야 할까? 쿼리, 키, 밸류 행렬은 어떻게 사용되는가? 이와 같은 방법의 장점은 무엇인가? 자세히 알아보도록 하자.셀프 어텐션의 작동 원리 이해하기앞에서 $Q, K, V$ 행렬 계산 방법과 해당 행렬을 입력 행렬로 얻을 수 있다는 것을 배웠다. 이제 쿼리, 키, 밸류 행렬을 셀프 어텐션에 어떻게 사용하는지 보자.앞서 단어의 표현을 계산하기 위해 셀프 어텐션은 각 단어를 기준으로 주어진 문장에 있는 모든 단어와 연결하는 과정을 수행하다는 사실을 배웠다. ‘I am good’이라는 문장을 예로 들어 보자. 단어 ‘I’의 표현을 계산하려면, [그림 1-8]처럼 단어 ‘I’와 전체 문장에 있는 단어와 연결하는 과정을 수행한다. 그림 1-8 셀프 어텐션 예제위와 같은 방법을 적용하는 이유는 무엇일까? 특정 단어와 문장 내에 있는 모든 단어가 어떤 연관이 있는지를 이해하면 좀 더 좋은 표현을 학습시키는데 도움이 된다. 이제 셀프 어텐션이 쿼리, 키, 밸류 값을 사용해 특정 단어와 문장 내에 있는 모든 단어를 연결하는 방법을 알아본다. 셀프 어텐션은 총 4단계로 이루어져 있다. 각 단계를 하나씩 짚어보자.1단계셀프 어텐션의 첫 번째 단계는 $Q$ 행렬과 $K^T$행렬의 내적 연산을 수행한다. 그림 1-9 쿼리, 키 행렬쿼리 행렬 $Q$와 키 행렬 $K^T$의 내적 연산 결과는 다음과 같다. 그림 1-10 쿼리, 키 행렬 내적 연산 결과이때 쿼리와 키 행렬 사이 내적을 계산하는 이유는 무엇일까? 연산 결과는 정확히 무엇을 의미하는가? $Q\\cdot K^T$의 결과에 대해 알아보자.[그림 1-11]에서 $Q\\cdot K^T$의 첫 번째 행을 보자. 첫 번째 행은 쿼리 벡터 $q_1(I)$과 키 벡터 $k_1(I), k_2(am), k_3(good)$의 내적을 계산한다는 것을 알 수 있다. 두 벡터 사이의 내적을 계산하면 두 벡터가 얼마나 유사한지를 알 수 있다.즉, 쿼리 벡터 $(q_1)$과 키 벡터 $(k_1, k_2, k_3)$ 사이의 내적을 계산하는 것은 쿼리 벡터 $q_1(I)$와 키 벡터 $k_1(I), k_2(am), k_3(good)$ 사이의 유사도를 계산한 것이다. $Q\\cdot K^T$ 행렬의 첫 번째 행을 보면 단어 ‘I’는 단어 ‘am’과 ‘good’보다 자신 (I)과 연관성이 더 높은 것을 알 수 있다. $q_1\\cdot k_1$의 내적값이 $q_1\\cdot k_2, q_1\\cdot k_3$ 보다 높기 때문이다. 그림 1-11 쿼리벡터와 키 벡터의 내적 계산 결과2단계다음 단계는 $Q\\cdot K^T$ 행렬의 키 벡터 차원의 제곱근 값으로 나눈 것이다. 이와 같은 방법을 적용하면 안정적인 경삿값(gradient)을 얻을 수 있다.$d_k$를 키 벡터의 차원(dimension)이라고 하자. 그러면 $Q\\cdot K^T$를 $\\sqrt{d_k}$로 나누면 된다. 위의 예제에서 키 벡터의 차원은 64이다. 64의 제곱근인 8로 $Q\\cdot K^T$를 나눈다. 그림 1-14 d_k의 제곱근으로 나누기3단계이전 단계에서 계산한 유사도 값은 비정규화된 형태(unnormalized form)다. 따라서 소프트맥스 함수를 사용해 정규화 작업을 진행한다. 소프트 맥스 함수를 적용하면 전체 값의 합은 1이되면 각각 0과 1사이의 값을 갖는다. 2단계의 결과에 소프트맥스 함수를 적용하면 다음과 같은 결과를 얻는다. 그림 1-15 소프트맥스 함수 적용 결과이러한 행렬을 스코어 행렬이라고 한다. 위 점수를 바탕으로 문장 내에 있는 각 단어가 문장에 있는 단어와 얼마나 연관되어 있는지 알 수 있다. 예를 들어 스코어 행렬의 첫 행을 보면 단어 ‘I’는 자기 자신과 90%, 단어 ‘am’과는 10%, 단어 ‘good’과는 3% 관련되어 있다는 것을 알 수 있다.4단계지금까지 쿼리, 키 행렬에 대해 내적을 계산하고, 소프트맥스 함수를 사용해 내적값에 대한 정규화 작업을 진행했다. 그 다음 과정은 어텐션 행렬 $Z$를 계산하는 것이다.어텐션 행렬은 문장의 각 단어의 벡터값을 갖는다. 앞에서 계산한 스코어 행렬인 $softmax({QK^T\\over \\sqrt{d_k}})$에 밸류 행렬 $V$를 곱하면 어텐션 행렬 $Z$를 구할 수 있다. 다음은 어텐션 행렬을 계산한 결과이다. 어텐션 행렬 $Z$는 각 점수를 기준으로 가중치가 부여된 벡터의 합으로 계산한다. 계산 결과를 한 줄 씩 살펴보자. 첫 마지막으로\\[z_1=0.9 \\cdot v_1(I)+0.07\\cdot v_2(am)+0.03\\cdot v_3(good)\\]위 식처럼 단어 ‘I’의 셀프어텐션 $z_1$은 각 밸류 벡터값의 가중치 합으로 계산된다. 즉 $z_1$의 값은 밸류 벡터 $v_1(I)$의 90% 값과 밸류 벡터 $v_2(am)$의 7% 값과 밸류 백터 $v_3(good)$의 3%값의 합으로 구한다.이런 계산방법의 장점은 무엇일까? “A dog ate the food because it was hungry”를 예로 들어 답해보자. 여기서 단어 ‘it’은 ‘dog’를 의미한다. 이때 단어 ‘it’에 대해 위의 방법으로 셀프 어텐션을 계산해 다음과 같은 결과를 얻었다고 가정해보자.\\[z_n=0.0\\cdot v_1(A)+1.0\\cdot v_2(dog)+\\cdots +0.0\\cdot v_9(hungry)\\]단어 ‘it’의 셀프 벡터값은 밸류 벡터 $v_2(dog)$가 100% 반영된 결과로 볼 수 있다. 이는 모델에서 ‘it’이 ‘food’가 아닌 ‘dog’와 관련이 있다는 것을 알 수 있다. 셀프 어텐션 방법을 적용하면 단어가 문장 내에 있는 다른 단어와 얼마나 연관성이 있는지를 알 수 있다.어텐션 행렬은 문장 내에 있는 단어의 셀프 백터 값으로 구성된 것을 알 수 있으며 다음 식으로 그 값을 구할 수 있다.\\[Z=softmax({QK^T\\over \\sqrt{d_k}})V\\]지금까지 살펴본 셀프 어텐션의 단계를 요약하면 다음과 같다. 쿼리 행렬과 키 행렬 간의 내적을 계산하고($Q\\cdot K^T)$ 유사도 값을 산출한다. $Q\\cdot K^T$를 키 행렬 차원의 제곱근$(\\sqrt{d_k})$로 나눈다. 스코어 행렬에 소프트맥스 함수를 적용해 정규화 작업을 진행한다. $(softmax({QK^T\\over \\sqrt{d_k}})).$ 마지막으로 스코어 행렬에 밸류 행렬을 곱해 어텐션 행렬 $Z$를 산출한다.그림으로 표현하자면 다음과 같다. 그림 1-22 셀프 어텐션 메커니즘셀프 어텐션은 쿼리와 키 벡터의 내적을 계산한 다음 $\\sqrt{d_k}$로 나누기 때문에 scale dot product 어텐션이라고도 부른다.1.2.2 멀티 헤드 어텐션 원리어텐션을 사용할 때 헤드 한 개만 사용한 형태가 아닌 헤드 여러 개를 사용한 어텐션 구조도 사용할 수 있다. 앞에서 어텐션 행렬 $Z$ 행렬을 계산하는 방법을 배웠다. 단일 어텐션 행렬 $Z$이 아닌 다중 어텐션 행렬을 계산해보자. 이런 계산법은 어떤 이점이 있을까?“All is well”이라는 문장으로 예를 들어 보자. 단어 “well”의 셀프 어텐션을 계산한다고 하자. 계산 결과 다음과 같은 결과를 얻었다고 가정하자.\\[Z_{well}=0.6\\cdot v_1(All) + 0.0\\cdot v_2(is) + 0.4\\cdot v_3(well)\\]위 식에서 볼 수 있듯이 단어 “well”의 셀프 백터값은 가중치를 적용한 각 단어의 벡터값의 합임을 알 수있다. 위의 내용을 좀 더 자세히 들여다보면 단어 “well’의 벡터값은 단어 “All”이 가장 우세하게 작용하는 것을 알 수 있다.하지만 문장 내에서 단어의 의미가 모호한 경우 역시 발생할 수 있다. 다음 문장을 예를 들어 보자. A dog ate the food becuase it was hungry.이 예제에서 단어 ‘it’의 셀프 어텐션을 계산해서 다음과 같은 결과를 얻었다고 가정하자.\\[z_{it}=0.0\\cdot v_1(A)+1.0\\cdot v_2(dog)+\\cdots + 0.0\\cdot v_9(hungry)\\]이 때 단어 ‘it’의 의미는 ‘dog’ 또는 ‘food’가 될 수 있는데 위의 결과는 단어의 의미가 잘 연결된 경우다.따라서 문장 내에서 모호한 의미를 가진 단어가 있을 경우에 앞의 예와 같이 적절한 의미를 가진 단어의 벡터값이 잘 할당되었을 경우에는 문장의 의미를 이해하는 데 좊은 영향을 줄 수있다. 하지만 그 반대의 경우, 즉, 의미가 맞지 않는 단어의 벡터값이 높을 경우에는 문장읭 의미가 잘 못 해석될 수 있다. 그래서 어텐션 결과의 정확도를 높이기 위해서 단일 헤드 어텐션 행렬이 아닌 멀티 헤드 어텐션을 사용한 후 그 결괏값을 더하는 형태로 진행한다. 이와 같은 방법을 사용하는데는 단일 헤드 어텐션을 사용하는 것보다 멀티 헤드 어텐션을 사용하면 좀 더 명확하게 문장의 의미를 이해할 수 있다는 가정이 깔려있다. 이제 멀티 헤드 어텐션에 대해 좀 더 자세히 알아보자.$h$개의 어텐션 행렬을 구할 수 있을 것이다. 8개의 어텐션 행렬을 구한다고 하면 해당 행렬을 계산한 후에 그 결과를 연결한 후 새로운 가중치 행렬 $W^O$를 곱하면 최종적으로 우리가 원하는 행렬곱을 구할 수 있다.\\[mha = concatenate(Z_1, Z_2, \\cdots, Z_8)\\cdot W_0\\]1.2.3 위치 인코딩으로 위치 정보 학습“I am good”이라는 입력 문장이 있다고 가정하자. RNN에서는 단어 단위로 네트워크에 문장을 입력한다. 처음에 “I”라는 단어가 입력으로 전달된 다음에 “am”이라는 단어가 전달된다. 네트워크는 문장을 완전히 이해하기 위해 문장을 단어 단위로 나누어서 입력한다. 하지만 트랜스포머 네트워크에서는 위와 같은 순환구조를 따르지 않는다. 단어 단위로 문장을 입력하는 대신에 문장 안에 있는 모든 단어를 병렬 형태로 입력한다. 병렬로 단어를 입력하는 것은 학습 시간을 줄이고 RNN의 장기 의존성 문제를 해결하는 데 도움이 된다.하지만 트랜스포머에서 단어를 병렬로 입력하면 한 가지 문제가 발생한다. 그것은 바로 단어의 순서 정보가 유지되지 않은 상태에서 문장의 의미를 어떻게 이해할 수 있느냐는 점이다.문장의 의미를 이해하기 위해서는 단어의 순서 (문장의 단어의 위치 정보)가 매우 중요하다. 문장의 의미를 명확히 이해하려면 단어의 위치 정보를 반드시 이해해야 한다.“I am good”이라는 문장으로 돌아가서, 처음에 문장 안의 각 단어에 대해 임베딩값을 얻는다. 이때 임베딩의 차원을 $d_{model}$이라고 한다. 여기서 임베딩 차원의 값을 4라고 한다면 문장에 대한 입력 행의 차원은 [문장 길이 x 임베딩 차원] = [3 x 4]가 된다.“I am good” 이라는 문장을 입력행렬(임베딩 행렬)로 표현하면 다음과 같다. 그림 1-25 입력 행렬입력 행렬을 트랜스포머에 바로 입력하면 단어의 순서 정보를 이해할 수 없다. 입력 행렬을 트랜스포머에 직접 전달하는 대신 네트워크에서 문장의 의미를 이해할 수 있도록 단어의 순서를 표현하는 정보를 추가로 제공해야 한다. 이를 위해 위치 인코딩이라는 새로운 방법을 활용한다. 위치 인코딩이라는 이름에서 알 수 있듯이 문장에서 단어의 위치를 나타내는 인코딩이다.위치 인코딩 행렬 $P$의 차원은 입력행렬 $X$의 차원과 동일하다. 이제 입력 행렬을 트랜스포머에 직접 입력하기 전에 위치 인코딩을 포함한다. 즉 입력 행렬 $X$에 위치 인코딩 $P$를 더한 후 네트워크에 입력하는 것이다. 이제 입력 행렬은 단어의 임베딩 뿐 아니라 문장의 단어 위치 정보도 포함한다. 그림 1-26 입력 행렬에 위치 인코딩 행렬값 추가그렇다면 위치 인코딩은 어떻게 계산되는 것일까? “Attention Is All You Need” 논문의 저자는 위치 인코딩을 계산하는데 사인파 함수를 사용했다.\\[P(pos, 2i)=\\sin({pos\\over 1000^{2i/d_{model}}}) \\\\ P(pos, 2i+1)=\\cos({pos\\over 1000^{2i/d_{model}}})\\]위의 식에서 $pos$는 문장에서의 단어의 위치를 의미하고, $i$는 해당 위치의 임베딩을 의미한다. 예제를 통해 해당 식의 의미를 이해해보자. 위의 식을 사용해 위치 인코더 행렬을 표현하면 다음과 같다.\\[P=\\begin{bmatrix} \\sin({pos\\over10000^0}) \\ \\cos({pos\\over10000^0}) \\ \\sin({pos\\over10000^{2/4}}) \\ \\cos({pos\\over10000^{2/4}}) \\\\ \\\\ \\sin({pos\\over10000^0}) \\ \\cos({pos\\over10000^0}) \\ \\sin({pos\\over10000^{2/4}}) \\ \\cos({pos\\over10000^{2/4}}) \\\\ \\\\ \\sin({pos\\over10000^0}) \\ \\cos({pos\\over10000^0}) \\ \\sin({pos\\over10000^{2/4}}) \\ \\cos({pos\\over10000^{2/4}}) \\end{bmatrix}\\]위치 인코딩 $P$를 계산한 후 임베딩 행렬 $X$에 요소별 합 (element-wise addition)을 수행한 후 인코더의 입력 행렬로 입력한다.인코더의 아키텍처를 다시 살펴보자. [그림 1-31]의 단일 인코더 블록을 보면 인코더에 입력 데이터는 입력 임베딩을 구한 다음 위치 인코딩을 합한 후 인코더에 입력하는 것을 알 수 있다. 그림 1-31 단일 인코더 블록1.2.4 피드포워드 네트워크인코더 블록 내 서브레이어에서 피드포워드 네트워크는 다음과 같이 표현할 수 있다. 그림 1-32 인코더 블록피드포워드 네트워크는 2개의 전결합층(dense layer)과 ReLU 활성화 함수로 구성된다. 피드포워드 네트워크의 변수(parameter)는 문장의 다른 위치에서는 동일하고 인코더 블록에서는 다르게 나타난다.1.2.5 add와 norm 요소인코더에서 중요한 요소 중 하나는 바로 add와 norm관련 부분이다. 이 부분은 서브레이어의 입력과 출력 부분에 연결되어 있다. 이는 [그림 1-33]에서 점선으로 표시된 부분이다. 이 부분을 자세히 보면 다음과 같이 구성됐다는 것을 알 수있다. 서브레이어에서 멀티 헤드 어텐션의 입력값과 출력값을 서로 연결한다. 서브레이어에서 피드포워드의 입력값과 출력값을 서로 연결한다. 그림 1-33 add와 norm이 추가된 인코더 블록add 와 norm 요소는 기본적으로 레이어 정규화 (layer normalization)과 잔차 연결(residual connection)이다. 레이어 정규화는 각 레이어 값이 크게 변화하는 것을 방지해 모델을 더 빠르게 학습할 수 있게 한다.1.2.6 모든 인코더 구성 요소 통합[그림 1-34]는 인코더 2개가 누적된 상태를 보여준다. 간결하게 표현하기 위해 인코더 1만 자세하게 표현했다. 그림 1-34 인코더 1을 확장한 인코더 누적위의 예제처럼 인코더를 $N$개 누적해서 생성한다. 최상위 인코더의 출력값(인코더 표현)은 주어진 인코더에 대한 표현값이 된다. 최종 인코더에서 얻은 인코더 표현을 $R$이라고 하자.$R$은 디코더의 입력값으로 들어간다. 디코더는 인코더 표현을 입력값으로 사용하고 타깃 문장을 생성한다." }, { "title": "적대적 공격에 저항하는 딥러닝 모델을 향하여 (Towards Deep Learning Models Resistant to Adversarial Attacks - Aleksnader Madry, Aleksandar Makelov, Ludwig Schmidt, Dimitris Tsipras, Adrian Vladu)", "url": "/posts/pgd/", "categories": "ADVERSARIAL TRAINING, PGD", "tags": "adversarial example", "date": "2022-07-30 22:00:00 +0900", "snippet": "의역 99%, 지적 태클 환영원문: Towards Deep Learning Models Resistant to Adversarial Attacks0 초록최근 연구들에서 심층 신경망이 adversarial example(원본 데이터와 거의 구별할 수 없지만 network가 오분류하는 입력)에 취약하다는 것과. adversarial attack의 존재가 딥러닝 모델의 내재적인 약점일 수 도 있다는 것이 밝혀졌다. 이를 해결하기 위해, robust optimization의 관점에서 신경망의 adversarial robustness를 살펴볼 것이다. 이러한 접근은 해당 주제의 이전 연구들보다 광범위하고 통일된 관점을 제공한다. 또한 이러한 원칙적인 성질은 신경망에 대한 훈련과 공격을 위한 신뢰할 수 있고, 어떤 의미에서는, 보편적인 방법을 제시할 수 있게 한다, 특히, 모든 적으로부터 보호할 수 있는 concrete security guarantee를 명시한다. 이러한 방법은 광범위한 적대적 공격에 크게 향상된 내성을 가진 network 훈련을 할 수 있게 하였다. 또한 자연스럽고 광범위한 security guarantee로써 first-order adversary에 대한 보안 개념을 제안한다. 우리는 이러한 adversaries의 잘 정의된 클래스가 완벽한 내성을 가진 딥러닝 모델로 향하는 디딤돌임을 믿는다.1 개요최근 컴퓨터 비전이나 자연어 처리에서의 획기적인 발전은 훈련된 분류기를 보안 중시 체계의 중심으로 끌어들이고 있다. 자율주행 자동차, 얼굴인식 그리고 멀웨어 감지는 대표적인 예시에 해당한다. 이러한 발전은 머신러닝의 보안적인 측면을 매우 중요하게 만들고 있다. 특히, 적대적으로 선택된 입력에 대한 저항이 중요한 설계 목표가 되고 있다. 잘 훈련된 모델은 일반적인 입력의 분류에 있어서 매우 효과적이지만, 최근 연구는 악의적으로 입력을 조작하여 모델이 잘못된 출력을 만들도록하는 것이 가능하다는 것을 보여준다.이러한 현상은 심층신경망의 맥락에서 관심을 받았었고, 현재는 이 주제에 대한 연구가 급속도로 이루어 지고 있다. 컴퓨터 비전은 특히 주목할 만한 도전을 제공한다: 입력 이미지에 미세한 변경만을 주어도 SOA 신경망을 높은 신뢰도로 속일 수 있다. 이때 모델은 일반적인 입력은 제대로 분류하며, 변경된 차이에 대해서 인간은 인지할 수 없다. 보안적인 부분을 떼고 생각하더라도, 이러한 현상은 현재의 모델이 견고한 방식으로 기저 개념을 학습하는게 아니라는 것을 입증한다. 이러한 모든 발견은 하나의 근본적인 질문을 떠오르게 한다:어떻게 하면 적대적 입력에 robust한 심층 신경망을 훈련할 수 있는가?현재 적대적인 환경에서의 공격과 방어에 대한 다양한 메커니즘을 제시한 상당한 양의 연구가 존재한다. defensive distillation, feature squeezing 그리고 일부 다른 적대적 예제 감지에 대한 접근이 이에 포함된다. 이 연구들은 이곳의 가능성의 영역을 탐구하는 중요한 첫 발자국이 되었다. 그러나 그들은 그들이 제공한 보장에 대한 양질의 이해를 제공하지 않는다. 우리는 주어진 공격이 맥락안에서 “가장 적대적인” 예인지, 혹은 특정한 방어 메커니즘이 어떤 종류의 적대적 공격을 예방하는지 결코 확신할 수 없다. 이는 adversarial robustness를 조사하거나 가능한 보안에 대한 효과를 완전히 평가하는 것을 어렵게 한다.본 문서에서는 robustness optimization의 관점에서 신경망의 adversarial roboustness를 조사할 것이다. 원칙적인 방식으로, 적대적 공격에 대한 보안의 개념을 잡기 위해 말 안장점(min-max) 공식을 사용한다. 이 공식은 달성하고자 하는 security guarantee의 유형, 즉 특정한 잘 알려진 공격만 방어하는 것과 달리, 광범위한 공격에 저항하는 것에 대해서 정확히 파악할 수 있게 해준다. 또한 공식화을 통해 공격과 방어를 모두 공통된 이론적 토대에 보낼 수 있으며, 적대적 예제에 대한 이전의 연구들의 대부분을 자연스럽게 캡슐화할 수 있게 한다. 특히, 적대적 훈련은 이 말안장점 문제를 최적화 하는 것에 직접적으로 연관되어 있다. 이와 유사하게, 신경망을 공격하는 이전의 방법들은 기저가 되는 제한된 최적화 문제를 푸는 특정한 알고리즘과 연관되어 있다.이러한 관점에서 우리는 다음과 같은 성과를 냈다. 우리는 이 말안장점 식과 관련된 optimization landscape(최적화 공간의 모양)의 세심한 실험적인 연구를 시행한 후, non-convexity와 non-concavity에도 불구하고, 내제된 최적화 문제가 다루기 쉽다는 것을 발견하였다. 특히, 우리는 first-order method가 확실히 이 문제를 해결할 수 있다는 강력한 증거를 제시한다. projected gradient descent(PGD)를 보편적인 “first-order adversary”로써 강하게 제시하는 실해석학(real analysis)에서의 아이디어와 함께 이러한 통찰을 보충할 것이다. first-order adversary란, network에 대한 local first order 정보를 이용한 가장 강한 공격이다. network 구조가 adversarial robustness에 미치는 영향과 model capacity가 이것에 중요한 역할을 한다는 것을 알아냈다. 강한 adversarial attack에 안정적으로 견뎌내기 위해, newtork에게는 일반적인 입력만을 올바르게 분류하는 데 필요한 것보다 더 큰 capacity가 요구된다. 이는 말안장점 문제의 robust decision boundary가, 일반적인 입력을 분류하는 decision bondary에 비해서 상당히 복잡해 질 수 있다는 것을 보여준다. 위의 통찰을 바탕으로, 광범위한 적대적 공격에 robust한 MNIST와 CIFAR에서 network를 훈련시켰다. 우리의 접근은 앞서 언급한 말안장점 공식 최적화에 기반했으며, 신뢰할 수 있는 first-order adversary로 PGD를 사용하였다. 우리의 최고의 MNIST 모델은 테스트 군의 가장 강한 adversary들로부터 89% 이상의 정확도를 달성했다. 심지어 우리의 MNIST network는 iterative adversary의 white box attack 에서도 robust하였다. 같은 adversary에서 우리의 CIFAR10 모델은 46%의 정확도를 달성했다. 더욱이, 약한 black box/transfer 공격에서, 우리의 MNIST와 CIFAR10 network는 각각 95%이상, 64%이상의 정확도를 달성했다(더 자세한 개요는 [표1]과 [표2]에서 볼 수 있다). 우리가 아는 한, 이러한 광범위한 종류의 공격에서 이 정도 수준의 robustness를 달성한 것은 우리가 최초이다.종합하자면, 이러한 발견들은 안전한 신경망이 도달 범위 안에 있음을 제시한다. 이 주장을 더욱 뒷받침 하기 위해, 우리는 challenge 형태로 우리의 MNIST와 CIFAR10 network을 공격하는 커뮤니티에 초대한다. 이것은 우리의 모델의 robustness를 정확하게 평가시켜줄 것이며, 그 과정에서 새로운 공격 방법으로 이어질 가능성이 있다. 도전 과제에 대한 설명과 전체 코드는 https://github.com/MadryLab/mnist_challenge 과 https://github.com/MadryLab/cifar10_challenge 에서 볼 수 있다.2 적대적 Robustness에 대한 최적화 관점우리의 논의의 대부분은 적대적 robustness를 주로 할 것이다. 이러한 관점은 우리가 연구하고자 하는 현상뿐만 아니라 연구 결과 또한 정확하게 포착할 수 있게 한다. 끝에서 기본이 되는 데이터 분포 $\\mathcal{D}$의 $x\\in\\mathbb{R}^d$에 대응하는 $y\\in[k]$ 예제 쌍에서의 표준 분류 작업을 고려할 것이다. 또한 신경망에서의 cross-entropy loss와 같은 적절한 손실 함수 $L(\\theta, x, y)$가 주어졌다고 가정한다. 늘 그렇듯, $\\theta \\in \\mathbb{R}^p$는 모델 파라미터의 집합이다. 이제 우리의 목표는 risk(=loss value) $\\mathbb{E}_{(x, y)\\sim \\mathcal{D}}[L(x, y, \\theta)]$를 최소화하는 모델 파라미터 $\\theta$를 찾는 것이다.Empirical risk minimization (ERM, 경험적 위험도 최소화)은 population risk가 작은 분류기를 찾는 것에 크게 성공적이었다. 불행하게도, ERM은 종종 적대적으로 생성된 예제들에 robust한 모델을 산출하지 않는다. 클래스 $c_1$에 속한 입력 $x$와, $x$와 매우 유사하지만 클래스를 $c_2\\not=c_1$으로 분류하는 입력 $x^{adv}$를 찾는 효율적이고 공식적인 알고리즘(이하 ”adversaries”)이 존재한다.적대적 공격에 신뢰적인 모델 훈련을 위하여, ERM 패러다임을 적절하게 보강하는 것이 필요하다. 우리는 특정한 공격에 대한 robustness를 직접적으로 향상시키는 방법들을 재정립하는 대신, adversarially model이 만족해야 하는 concrete guarantee를 최초로 제시한다. 그런 다음, 해당 guarantee를 달성하는 쪽으로 모델을 적응시킨다.이러한 guarantee를 향한 첫 발걸음은, 모델이 저항해야 하는 공격의 정확한 정의인 attack model을 특정하는 것이다. 각 데이터 포인트 $x$에 대한 허용된 교란들의 집합$\\mathcal{S}\\subseteq \\mathbb{R}^d$을 소개한다. $\\mathcal{S}$는 adversary의 조작력(manuipulative power)를 공식화한다. 이미지 분류에서 $\\mathcal{S}$를 선택하여 이미지들 사이의 지각적인 유사성(perceptual similarity)을 포착한다. 예를 들어, $x$를 중점으로 하는 $\\ell_\\infty$-ball이 적대적 교란에 대한 기본적인 개념으로 최근 연구되어 왔다. 우리는 본 논문에서 $\\ell_\\infty$-bounded 공격에 대한 robustness에 초점을 맞추지만, 지각적 유사성에 대한 보다 포괄적인 개념은 향후 연구의 중요한 방향이라는 것을 언급한다.다음으로, 위의 adversary를 포함하도록 population risk $\\mathbb{E}_\\mathcal{D}[L]$에 대한 정의를 변경한다. 분포 $\\mathcal{D}$에서 loss $L$로 샘플들을 직접 주는 대신, 먼저 adversary가 입력을 교란시키도록 한다. 이는 우리 연구의 중심 목적인 다음의 말안장점 문제를 떠오르게 한다.\\[\\min_\\theta \\rho(\\theta), \\quad\\text{where}\\quad \\rho(\\theta)=\\mathbb{E}_{(x,y)\\sim\\mathcal{D}} \\big[ \\max_{\\delta\\in\\mathcal{S}}L(\\theta, x+\\delta, y)\\big] \\tag{2.1}\\]이러한 유형의 식(그리고 유한한 샘플들에 대한 각각의 대응물)은 Wald[30]으로 거슬러 올라가는 robust optimization에서 유구한 역사를 가지고 있다. 위 식은 우리 연구의 맥락에서 특히 유용하다.첫째로, 이 식은 adversarial robustness에 대한 이전의 연구들을 아우르는 통합된 관점을 제공한다. 우리 관점의 줄기는 말안장점 문제를 속에 있는 것을 최대화(inner maximization)하고 겉에 있는 것을 최소화(outer minimization)하는 것으로 부터 비롯된다. 이 둘 모두 우리 맥락에 대한 자연스러운 해석을 가지고 있다. 내부 최대화 문제는 주어진 데이터 포인트 $x$에 대해, 높은 손실을 갖는 적대적 버전을 찾는 것을 목표로 한다. 이는 정확히 주어진 신경망을 공격하는 문제이다. 반면, 외부 최소화 문제의 목적은 model parameter를 찾아서, 내부 공격 문제가 제공한 “적대적 손실”을 최소화 하는 것이다. 이는 정확히 적대적 훈련 기술을 사용해 robust한 분류기를 훈련하는 문제이다.둘째로, 말안장점 문제는 이상적인 robust 분류기가 달성해야 하는 명확한 목적을 robustness의 수치적인 척도로 제시한다. 특히, parameters $\\theta$가 (거의) 희미한 risk를 산출했을 때, 해당 모델은 우리의 attack model이 한 공격에 대해 완벽하게 robust한 것이다.본 논문은 심층 신경망의 맥락에서 말안장점 문제의 구조를 연구한다. 이러한 연구는 광범위한 적대적 공격에 대한 높은 내성을 가진 모델을 생성하는 훈련 테크닉을 발견할 수 있게 한다. 우리의 성과에 들어가기 앞서, 적대적 예제에 대한 이전의 연구들을 간단히 리뷰하고, 이것이 어떻게 위 식에 맞춰지는 지 자세하게 설명한다.2.1 공격과 방어에 대한 통합적인 관점적대적 예제에 대한 이전의 연구들은 다음 두 주요한 질문에 집중된다. 어떻게 하면 강력한 적대적 예제(작은 교란만을 요구하면서 높은 신뢰도로 모델을 속일 수 있는)를 생성할 수 있는가? 어떻게 하면 적대적 예제가 없게끔, 최소한 적대적 예제를 쉽게 찾을 수 없게끔 모델을 훈련시킬 수 있는가?말안장점 문제(2.1)에서 우리의 관점은 위 둘 문제 모두에서 해답을 주었다. 공격 측면에서, 이전의 연구는 FGSM[11]과 이것의 다양한 변형[18]과 같은 방법들을 제시했다. FGSM은 $\\ell_\\infty$-bounded adversary 공격이며 다음과 같이 적대적 예제를 계산한다.\\[x+\\epsilon \\ \\text{sgn}(\\nabla_xL(\\theta,x, y)).\\]이 공격을 말안장점 공식의 내부를 최대화하는 간단한 one-step 방식의 공격으로 해석할 것이다. 더 강력한 adversary는 multi-step 변형인데, 이는 근본적으로 다음과 같은 음의 손실 함수에서의 사영된 경사 하강(projected gradient descent, PGD)이다.\\[x^{t+1}=\\mathrm{\\Pi}_{x+\\mathcal{S}}(x^t+\\alpha \\ \\text{sgn}(\\nabla_x L(\\theta, x, y))).\\]무작위 교란의 FGSM같은 다른 방법들[29]이 제시되어 왔다. 명확하게, 이러한 접근들은 모두 (2.1)의 내부 최대화 문제를 해결하려는 개별적인 시도로 볼 수 있다.방어 측면에서, 훈련 데이터셋은 종종 FGSM으로 생성한 적대적 예제들에 의해 보강된다. 최대화 문제를 선형화하는 이러한 접근도 (2.1)로부터 얻어진다. 단순화된 robust optimization 문제를 해결하기 위해, 모든 훈련 예제들을 FGSM으로 교란된 예제들로 대체하였다. 여러 adversary들로부터 훈련하는 것 같은 더욱 정교한 방어 메커니즘이 내부 최대화 문제의 더 좋고 철저한 근사라고 볼 수 있다.3 보편적인 Robust Network를 향하여적대적 예제의 현재의 연구는 보통 특정한 방어 메커니즘이나, 혹은 그러한 방어에 대한 공격에 집중한다. 공식 (2.1)의 중요한 특징은 작은 적대적 loss가, 허용된 공격에 대해서 신경망을 속이지 못한다는 guarantee를 준다는 것이다. 정의에 의해, 우리의 공격 모델로부터 허용된 모든 교란에 대한 loss가 작기 때문에, 어떠한 적대적 교란도 가능하지 않다. 이런 이유로, 이제부터 (2.1)의 양질의 해를 얻는 것에 집중할 것이다.불행하게, 말안장점 문제가 준 종합적인 gurarantee는 분명히 유용하지만, 합리적인 시간에 좋은 해를 찾을 수 있는지는 명확하지 않다. 말안장점 문제 (2.1)을 푸는 것은 non-covex한 외부 최소화 문제와 non-concave한 내부 최대화 문제를 둘 다 붙잡고 씨름하는 것을 포함한다. 우리의 주요 성과 중 하나는 실제로 말안장점 문제를 해결할 수 있다는 것을 입증한 것이다. 특히, 이제부터 우리는 non-concave한 내부 문제 구조의 실험적인 연구에 대해서 논의한다. 우리는 이 문제와 연관된 loss 공간의 모양이 놀랍게도 local maxima를 다루기 쉬운 구조임을 입증할 것이다. 또한 이런 구조는 “궁극적인” first-order adversary로써 PGD를 가리킨다. 섹션 4와 5에서, network가 충분히 크다면, 훈련된 network의 결과가 광범위한 공격에 실제로 robust하다는 것을 보인다.3.1 적대적 예제의 Landscape내부 문제가 주어진 network와 데이터 포인트에 대해서 적대적 예제를 찾는 것임을 상기하자 (우리의 공격 모델로). 이 문제는 highly nonconcave한 함수를 최대화할 것을 요구하므로, 다루기 어렵다고 생각할 수 있다. 실제로, 이것은 내부 최대화 문제를 선형화하는 데 의존한 이전 연구에 의해 도달한 결론이다[15, 26]. 위에서 지적한 바와 같이, 이러한 선형화 접근은 FGSM과 같이 잘 알려진 방식을 산출한다. FGSM adversaries에 대해 훈련하는 것은 일부 성공을 보였지만, 최근 연구는 이 one-step 접근법의 중요한 단점을 강조한다. 즉, 미세하게 더 정교한 adversary들이 여전히 높은 loss를 갖는 입력을 찾을 수 있다는 것이다.더 자세하게 내부 문제를 이해하기 위해, 우리는 MNIST와 CIFAR10에서의 여러 모델의 local maxima 공간의 모양을 연구한다. large-scale constrained opimization의 표준 방법이기 때문에, 실험의 주요 도구는 PGD이다. loss 공간의 모양의 많은 부분을 탐색하기 위해, 각 검증 셋트의 데이터 포인트를 둘러싸는 $\\ell_\\infty$-ball 의 많은 지점에서 PGD를 재시작한다.놀랍게도, 실험 후 적어도 first-order 방법들에서는 내부 문제가 다루기 쉽다는 것을 발견했다. $x_i+\\mathcal{S}$안에 많은 local maxima를 갖는 적대적 입력이 넓고 띄엄띄엄하게 흩뿌려져 있었지만, 매우 일관된 loss 값을 갖는 경향이 있었다. 이는 loss(model parameter에 대한 함수로써)가 일반적으로 매우 유사한 값을 가진 많은 local maxima를 가지기 때문에 신경망 훈련이 가능하다는 전통적인 믿음을 반영한다.실험은 아래와 같은 특별한 현상들을 발견했다. 우리는 $x+\\mathcal{S}$안의 무작위로 선택된 시작점에서 projected $\\ell_\\infty$ gradient descent를 사용할 때 adversary에 의해 달성된 loss가 상당히 일관적으로 빠르게 증가하는 것을 발견했다. ([그림1] 참조) [그림1] MNIST와 CIFAR10 검증 데이터셋에서 적대적 예제를 생성하는 동안의 cross-entropy loss값. 이 그림들은 PGD가 20 step 동작할 동안 손실이 어떻게 증가하는 지 보여준다. 각각의 동작은 동일한 일반 입력을 둘러싸고 있는 $\\ell_\\infty$-ball안의 균등하게 무작위인 점에서 시작하였다(다른 예제에 대한 추가적인 그림은 [그림11]에 있다). 적대적 손실은 적은 수의 반복 이후에 수평을 이룬다. 최적화 궤적과 최종 loss 값이 CIFAR10에서 특히, 상당히 몰려있다. 더욱이, 적대적으로 훈련된 network의 최종 loss 값은 표준 훈련보다 훨씬 작다. maxima의 집중에 대해 더욱 조사하여, 많은 수의 무작위 재시작을 관찰하였고, 최종 반복의 loss 값이 극단적인 이상치 없이 잘 집중된 분포를 따른다는 것을 관찰하였다. ([그림2] 참조; $10^5$번의 재시작을 기반으로 이 집중을 확인하였다) [그림2] MNIST와 CIFAR10 검증 데이터셋에서 다섯개의 예들에 대한 cross-entropy loss에서 주어진 local maxima값들. 각 예들은 예제들을 둘러싼 $\\ell_\\infty$-ball안의 균일하게 무작위한 $10^5$개의 지점에서 PGD를 시작하였고, 손실이 평평해질 때까지 PGD를 반복하였다. 파란 히스토그램은 표준 network의 손실에 해당하는 반면, 빤간 히스토그램은 적대적으로 훈련된 network의 손실에 해당한다. 적대적으로 훈련된 network의 손실이 눈에 띄게 작고, 최종 손실값들이 이상치 없이 매우 집중적이다. maxima가 눈에 띄게 분리되어 있다는 것을 보이기 위해 모든 쌍 사이의 $\\ell_2$ 거리와 각도를 측정하였고, 거리들이 $\\ell_\\infty$-ball안의 두 개의 무작위 지점 사이의 예상된 거리와 유사하게 분포되었다는 것과, 수직에 가까운 각도를 가진다는 것을 관찰하였다. local maxima 사이의 선분에 따르면, loss는 convex하며, 끝점에서 최댓값을 이루고 중간에서 상수 인자에 의해 감소된다. 그럼에도 불구하고, 전체 선분에서 손실은 무작위 지점에서의 손실보다 상당히 높다. 마지막으로, 우리는 maxima의 분포가 최근 발전된 적대적 예제에 대한 부분 공간 관점이 공격의 풍부함[29]을 완전히 포착하지 못한다는 것을 시사한다는 것을 발견했다. 특히, 입력의 그레디언트와 함께 음의 내적을 사용한 적대적 교란과, 교란의 규모가 증가함에 따라 그레디언트 방향과의 전반적인 상관관계가 약화된다는을 관찰했다.이러한 모든 증거들은 다음에 보게 될 것처럼 PGD가 first-order 접근법들 사이에서 “보편적인” adversary라는 것을 가리킨다.3.2 First-Order Adversaries우리의 실험은 PGD가 찾은 local maxima가 일반적으로 훈련된 network와 적대적으로 훈련된 network 에서 모두 비슷한 손실값을 가진다는 것을 보여준다. 이런 집중적인 현상은 PGD adversary에 대한 robustness가 모든 first-order adversary들에 대한 robustness를 산출한다는 문제에 대한 흥미로운 관점을 시사한다. adversary가 입력에 관한 손실 함수의 그레디언트만 사용하는 한, PGD보다 훨씬 더 나은 local maxima를 찾지 못할 것으로 간주된다. 이 가설에 대한 더욱 실험적인 근거를 섹션5에서 다룰것이다: 만약 PGD adversary들에 robust하도록 network를 훈련한다면, 이것은 광범위한 다른 공격에도 robust하다.물론, PGD에 대한 우리의 연구는 훨씬 더 큰 함숫값을 갖는 어떤 고립된 maxima의 존재를 배제하지 않는다. 그러나, 우리의 실험은 그러한 더 큰 local maxima가 first-order method로는 찾기 힘들 것임을 시사한다. 많은 무작위 재시작의 시도에도, 크게 다른 손실값의 함숫값을 찾지 못하였다. adversary의 계산 능력을 attack model에 통합하는 것은 현대 암호학의 초석인 polynomially bounded adversary의 개념을 연상시켜야 한다. 거기서, 이 고전적인 attack model은 adversary에게 해결하는 데 다항 시간이 드는 문제들만 풀 수 있도록 허락한다. 여기서 우리는 머신러닝 맥락에 더 적합하도록 adversary의 능력에 optimization-based 관점을 채용하였다. 결국에는, 우리는 많은 최근 머신 러닝 문제들의 대한 계산복잡도의 철저한 이해를 아직 개발하지 못했다. 그러나, ML의 대부분의 optimization 문제는 first-order 방법으로 해결되며, SGD의 변형들은 특히 딥러닝 모델을 훈련시키는 가장 효과 적인 방법이다. 따라서 우리는 first-order정보에 의존하는 형식의 공격이, 어떤 의미에서는, 딥러닝의 현재 관행에 보편적이라고 믿는다.이 두가지 아이디어를 종합하면, robustness가 보장된 머신 러닝 모델로 가는 길이 도표화 된다. 네트워크를 PGD adversary에 대해 robust하도록 훈련하면 현재의 모든 접근 방식을 포괄하는 광범위한 공격에 대해 robust해질 것이다.실제로, 이러한 robustness는 black-box attacks의 맥락에서 더욱 강해지는 것을 보장한다. 블박 어택이란, adversary가 target network에 직접적인 접근이 불가능한 상태에서 하는 공격을 뜻한다. 대신, adversary는 (대략적인)모델의 아키텍쳐나 훈련 데이터셋과 같은 보다 적은 특정한 정보만을 가진다. 이러한 attack model을 “zero order” 공격의 예시로 볼 수 있다. “zero order” 공격이란, adversary가 분류기에 직접적인 접근이 불가능하며, gradient feedback이 없는 특정 예제에 대한 검증만이 가능한 공격을 말한다.우리는 appendix의 섹션 B에서 transferability에 대해 논의한다. 우리는 network capacity를 늘리고 훈련하는 상대(표준적인 훈련 대신 FGSM or PGD 훈련)를 강화시키면 transfer attack에 대한 내성이 향상된다는 것을 관찰했다. 또한, 예상한 것처럼, 그러한 공격에 대한 우리의 최고의 모델의 내성은 (가장 강한)first order 공격보다 훨씬 더 큰 경향이 있다.3.3 적대적 훈련의 Descent Directions앞서한 논의는 내부 optimization problem이 PGD를 적용함으로써 성공적으로 해결될 수 있다는 것을 시사한다. adversarially robust network를 훈련하기 위해, 우리는 (2.1) 말안장점 공식의 외부 optimization 문제 또한 해결할 필요가 있다. 즉, 내부 최대화 문제의 “적대적 손실”을 최소화하는 model parameter를 찾는 것이다.신경망 훈련의 맥락에서, 손실함수를 최소화 하는 대표적인 방법은 Stochastic Gradient Descent (SGD)이다. 외부 문제의 그레디언트인 $\\nabla_\\theta\\rho(\\theta)$를 계산하는 자연스러운 방법은 내부 문제의 최대치에서 손실함수의 그레디언트를 계산하는 것이다. 이는 적대적 교란으로 입력을 대체하고 교란된 입력에 대해 일반적인 훈련을 하는것에 해당된다. 이것이 말안장점 문제에 대한 유효한 descent direction인지는 명확하지 않다. 그러나, 연속이고 미분가능한 함수의 경우, Danskin 정리(opimization의 고전적인 정리)는 이것이 실제로 참이며, 내부 최대치에서의 그레디언트는 말안장점 문제에서의 올바른 descent direction임을 설명한다.Danskin 정리의 정확한 가정은 우리의 문제에 해당하지 않지만 (ReLU와 max-pooling 유닛으로 인해, 함수는 불연속이고 미분 불가능하며, 내부 문제의 근사적인 최대치만 계산하고 있다). 우리의 실험은 문제를 최적화하기 위해 이러한 그레디언트를 여전히 사용할 수 있음을 알려준다. 적대적 예제에서 손실의 그레디언트를 사용하여 SGD를 적용하면 [그림5]에서 볼 수 있듯이 훈련 중 말안장점 문제의 손실을 지속적으로 줄일 수 있다. 이러한 관찰은 우리가 신뢰할 수 있게 말안장점 문제 (2.1)을 최적화할 수 있다는 것과, 따라서 robust 분류기를 훈련할 수 있다는 것을 시사한다. 우리는 Danskin 정리를 수식적으로 설명하고 우리의 문제에 어떻게 적용됬는지 Appendix. A에서 설명한다.4 Network Capacity와 적대적 Robustness성공적으로 (2.1) 방정식을 해결하는 것은 robust를 보증하고, 분류기를 정확하게 하는 것에 충분하지 않다. 해당 문제에 대한 value(적대적 예제에 대해서 달성한 최종 loss)가 작고, 따라서 분류기의 동작이 guarantee를 제공한다는 것을 입증할 필요가 있다. 특히, 매우 작은 loss 값의 달성은 적대적 입력에 robust한 완벽한 분류기에 해당한다.가능한 교란들의 고정된 집합 $\\mathcal{S}$에 대해, 이 문제의 값은 우리가 학습하는 분류기의 아키텍쳐에 완전히 종속적이다. 결과적으로, 모델의 아키텍처 capacity는 전체적인 성능의 영향을 주는 주요한 요인이다. 높은 수준에서 말하자면(추상적으로), robust한 방식으로 예제들을 분류하는 것은 강력한 분류기를 요구하는데, 이는 적대적 예제의 존재가 문제의 decision boundary를 보다 복잡하게 만들기 때문이다. ([그림3] 참조) [그림3] 표준 decision boundary와 적대적 decision boundary의 개념도. 왼쪽은 간단한 decision boundary로 쉽게 분류 가능한 점들의 집합임. 가운데는 데이터 포인트를 둘러싸는 $\\ell_\\infty$-ball(사각형)을 분류하지 못하는 단순한 decision boundary. 따라서 적대적 예제들(빨간 별)이 오분류된다. 오른쪽은 $\\ell_\\infty$-ball을 분류하기 위한 더 복잡한 decision boundary임. 해당 분류기는 유계 $\\ell_\\infty$-norm 교란의 적대적 예제에 대해 robust하다.우리의 실험은 capacity가 강력한 adversary들에 대하여 성공적으로 훈련하는 것과, robustness에 중요하다는 것을 증명했다. MNIST 데이터셋에서, 우리는 간단한 합성곱 신경망을 고려하였고, 여러 adversary들로부터 network의 크기를 두 배씩 늘릴 때 어떻게 행동이 변화하는지 연구하였다. (합성곱 필터의 수와 fully connected layer의 크기를 두 배로 늘렸다.) network는 2개 필터의 합성곱 layer와, 이어서 4개의필터가 있는 또 다른 합성곱 레이어 그리고 64개의 유닛의 fully connected layer로 초기화되었다. 합성곱 레이어 뒤에는 $2\\times 2$ max-pooling 레이어가 따르고 $\\epsilon=0.3$의 적대적 예제로 구성되었다. 결과는 [그림4]에 있다.CIFAR10 데이터셋에서는 ResNet 모델을 사용하였다. random crops와 flips를 이용하여 data augmentaion과 image standarization을 수행하였다. capacity를 늘리기 위해, network의 더 넓은 레이어를 포함하는 레이어를 10배로 수정하였다. 이는 각각 (16, 160, 320, 640)의 필터를 가진 5개의 residual unit의 network를 만들어냈다. 이 network는 일반적인 입력에서 훈련했을 때 95.2%의 정확도를 달성할 수 있었다. 적대적 예제는 $\\epsilon=8.$로 만들어졌다. capacity 실험에 대한 결과는 [그림 4]에 있다. [그림4] network의 성능에서의 network capacity의 영향. 다양한 capacity에서 MNIST와 CIFAR10 network를 훈련하였다. (a)는 일반적인 입력이고, (b)는 FGSM이 만든 적대적 입력들, (c)는 PGD가 만든 적대적 입력이다. 각 데이터셋의 첫 세 개의 그림과 표에서, 표준과 적대적인 각각의 훈련 체제 하에서의 capacity에 따른 정확도의 변화를 보였다. 마지막 그림과 표에서는, network가 훈련된 적대적 입력들의 cross-entropy loss의 값을 보였다. 이는 허용된 교란들의 여러 집합들에 대한 말안장점 문제(2.1)의 값에 해당한다.우리는 다음과 같은 현상들을 관찰했다:capacity만으로도 도움이된다. 우리는 일반적인 예제들만으로 훈련할 때, network의 capacity를 늘리는 것이 one-step 교란의 robustness를 향상시키는 것을 관찰했다.FGSM adversary들은 robustness를 향상시키지 않는다 (큰 $\\epsilon$ 에 대해서). FGSM에서 생성된 적대적 입력들을 사용하여 network를 훈련할 때, network가 이러한 적대적 예제에 과적합되는 것을 발견했다. 이러한 행동은 label leaking[18]으로 알려져 있으며, adversary가 network가 과적합 할 수 있는 매우 제한적인 적대적 예제들의 집합을 생성한다는 사실에서 비롯된다. 이러한 network들은 일반적인 입력에서 좋지 않은 성능을 가지며, PGD adversary에 대한 어떤 종류의 robustness도 보이지 않았다. 더 작은 $\\epsilon$의 경우, 일반적인 입력을 둘러싸고 있는 $\\ell_\\infty$-ball에서의 loss는 종종 충분히 선형적이어서, FGSM은 PGD에 의해 발견되는 것들과 유사한 적대적 예제를 발견하기 때문에, 훈련하기에 합리적adversary가 되는 것이다.나약한 모델은 비자명한 분류기를 학습하는 데 실패할 수 있다. 작은 capacity의 network의 경우, 일반적인 훈련에서는 정확한 분류기가 될 수 있음에도 불구하고, 강력한 adversary (PGD)에 대한 훈련의 시도는 유의미한 것들의 학습을 막는다. 이 network는 항상 고정된 클래스를 예측하는 것에 수렴한다. network의 작은 capacity는 적대적인 입력에 대한 어떤 종류던지, robustness를 제공하기 위해 학습 과정에서 일반적인 입력에 대한 성능을 희생시키는 것을 강제한다.말안장점 문제의 값은 capacity를 증가시킨 만큼 감소한다. adversary 모델을 고정시키고, 그것에 대해 훈련시킬 때, (2.1)의 값은 capacity가 증가한 만큼 감소했으며, 이는 모델이 적대적 예제에 더 적합될 수 있음을 의미한다.큰 capacity와 강력한 adversary들은 transferability를 감소시킨다. network의 capacity를 증가시키거나, 내부 최적화 문제에 강력한 방법을 쓰는 것은 전이가능한 적대적 입력의 효율성을 감소시킨다. 우리는 source network와 transfer network의 그레디언트 간의 상관 관계가 capacity가 증가할 수록 덜 중요해지는 것을 관찰하여 이것을 실험적으로 검증했다. appendix B에서 이 실험에 대해 설명한다.5 실험: 보편적으로 Robust한 딥러닝 모델이전 섹션에서의 문제에 대한 이해에 따라, robust한 분류기를 훈련하는데 우리가 제안한 접근법을 적용시킬 수 있다. 우리의 실험들이 지금까지 입증했듯이, 두 가지 핵심 요소에 초점을 맞출 필요가 있다: a) 충분히 큰 capacity의 network를 훈련시키고, b) 가능한 가장 강력한 adversary를 사용한다.MNIST와 CIFAR10 모두에서, 선택된 adversary는 일반적인 입력 주변의 무작위 교란에서 시작하는 PGD가 될 것이다. 이는 “완전한” first-order adversary에 대한 우리의 개념에 해당하며, 오직 first order 정보만을 사용하여 입력에 대한 loss를 효율적으로 최대화하는 알고리즘이다. 여러 에폭으로 모델을 훈련시키기 때문에, 배치마다 여러번 PGD를 재시작하는 것은 아무 이득도 없다. 즉, 각 입력을 마주칠 때마다 새로운 시작점이 선택될 것이다.이러한 adversary에 대해서 훈련시킬 때, [그림 5]에서 나오듯이, 적대적 예제의 training loss에서의 꾸준한 감소를 관찰했다. 이러한 행동은 훈련시키는 동안 실제로 성공적으로 원래의 optimization 문제를 해결하고 있다는 것을 가리킨다. [그림5]: 훈련시키는 동안 적대적 예제에 대한 training loss. 이 그림들은 PGD adversary에 대한 MNIST와 CIFAR10 network의 훈련 예제에서의 adversarial loss가 어떻게 진행되는지 보여준다. CIFAR 10그림에서의 급격한 감소는 훈련 step 크기를 감소시킨것에 해당한다. 이 그림들은 지속적으로 말안장점 문제 (2.1)의 내부 문제의 값을 감소시키는 것을 보여주고, 따라서 robust 분류기를 향상적이게 생성하고 있다.우리는 다양한 범위의 adversary에 대해서 훈련된 모델들을 평가했다. [표1]에서 MNIST에 대한 결과를 보이고, [표2]에서는 CIFAR10에서의 결과를 보인다. 우리가 고려한 adversary는 다음과 같다: source $A$로 표시되는 다양한 횟수의 반복과 재시작의 PGD white-box 공격. Carlini-Wagner(CW) loss 함수(정답과 오답의 logit의 차이를 직접적으로 optimizing함)[6]를 사용한 PGD white-box 공격. CW로 표시되며, 높은 신뢰도의 파라미터(k=50)의 해당되는 공격은 CW+로 표시된다. $A’$로 표시되는 독립적으로 훈련된 network의 사본에서의 Black-box 공격. $A_{nat}$로 표시되는 동일한 network의 일반적인 입력에서만 훈련된 버전에서의 black-box 공격. $B$로 표시되는 다양한 합성곱 아키텍처에서의 black-box 공격.MNIST. 우리는 adversary로써 0.01의 step size로 40번 반복한 PGD을 사용하였다 ($\\ell_\\infty$ norm에서의 그레디언트 스텝을 취하기를 선택했다. 즉, step size를 간단히 만들어주기 때문에, 그레디언트의 부호를 더한 것이다). $\\epsilon=0.3$크기의 교란에 대해서 훈련하고 검증하였다. 1024 크기의 fully connected 레이어와, 각각 $2\\times 2$ max pooling과, 32개와 64개의 필터의 두 개의 합성곱 레이어로 구성된 network를 사용하였다. 일반적인 입력에서 훈련시킬 때, 이 network는 검증 셋에서 99.2%의 정확도를 달성하였다. 그러나 FGSM으로 교란된 입력에서 검증했을 때 정확도는 6.4%로 떨어졌다. 이 적대적 정확도 결과는 [표1]에서 보고된다. 주어진 MNIST 모델의 결과는 $\\ell_\\infty$-bounded adversary들에게 매우 robust하였고, 적대적 robustness에 영향을 미치는 지 이해하기 위해 학습된 파라미터를 조사하였다. 조사의 결과는 Appendix C에서 설명한다. 특히, 우리는 network의 첫번째 합성곱 레이어가 다른 가중치들은 sparse한 경향을 보이는 데 비해 입력 픽셀들의 threshold를 학습한다는 것을 발견하였다. [표1]: MNIST: 다양한 adversary에 대해서 $\\epsilon=0.3$으로 적대적 훈련된 모델의 성능. 각 공격 모델에 대한 가장 성공적인 공격은 볼드체임. 공격을 위해 사용된 source network는 다음과 같다. 그 network 자체 (A) (white-box attack), 독립적으로 초기화되었으며, 이 훈련된 네트워크의 복사본 (A’), [29]의 아키텍처 (B).CIFAR10. CIFAR10 데이터셋에서, 4에서 설명한 두 개의 아키텍쳐(original ResNet과 이것의 10x 변형)를 사용하였다. 다시 $\\ell_\\infty$ PGD adversary를 사용하여 network를 훈련시켰고, 이번에는 size 2의 7 스텝을 사용하였으며, 총 $\\epsilon=0.8$ 이다. 다른 하이퍼파라미터의 선택이 정확도의 유의미한 감소를 일으키지 않았기 때문에, 가장 빡센 adversary로 같은 설정의 20스텝을 선택하였다. 실험의 결과는 [표2]에 나와있다. [표2]: CIFAR10: $\\epsilon=8$의 다양한 adversary에 대해서 적대적으로 훈련된 모델들의 성능. 각 공격 모델에 대해서 가장 효과적인 공격은 볼드체로 표시하였다. 공격을 위해 고려된 source network는 다음과 같다: 이 network 자체 (A) (white-box attack), 독립적으로 초기화되고, 이 모델의 훈련된 복사본 (A’), 일반적인 입력에서 훈련된 network의 복사본 ($A_{nat}$)반복적인 adversary들의 힘을 고려할 때 network의 적대적 robustness는 상당한 수준이었지만 만족하기엔 부족했다. 이러한 방향으로 밀고 나가는 것과 더 큰 capacity의 network를 훈련시킴으로써 이러한 결과를 개선할 수 있다고 믿는다.$\\ell_2$ 와 $\\epsilon$의 여러 값들에 따른 저항-bounded attacks. 모델의 적대적 robustness의 넓은 평가를 수행하기 위해, 두가지 추가적인 실험을 하였다. 하나는 여러값들의 $\\epsilon$에 따른 $\\ell_\\infty$ bounded attack에 대한 내성을 조사하는 것이었고, 다른 하나는 $\\ell_\\infty$-norm과 반대로 $\\ell_2$-norm에서의 bouned attack에 대한 저항을 시험하는 것이었다. $\\ell_2$-bouned PGD의 경우, 부호가 아닌 그레디언트 방향으로 스텝을 취하고 스텝 사이즈 조정을 용이하게 하기 위해 스텝을 고정된 크기로 정규화했다. 모든 PGD 공격에서 $\\epsilon$-ball안의 어떤 점에서 시작하던지 그것의 경계에 도달하는 것을 보장하기 위해 100스텝을 사용하였고, 스텝 사이즈를 $2.5\\cdot \\epsilon/100$으로 하였다. (경계에서의 움직임은 여전히 허용된다.) $\\ell_\\infty$-bounded attack에 대해 훈련된 모델은 MNIST에서 $\\epsilon=0.3,$ CIFAR10에서 $\\epsilon=8$을 사용했음을 상기하자. [그림6]에 이 결과가 나와있다. [그림6]: 다양한 강도의 PGD adversary들에 대해서 적대적으로 훈련 network의 성능. MNIST와 CIFAR10 network는 각각 $\\epsilon=0.3$과 $\\epsilon=8$의 PGD $\\ell_\\infty$ adversary에 대해서 훈련되었다. (이 훈련 $\\epsilon$은 $\\ell_\\infty$플롯에서 빨간 점선으로 표현된다. MNIST에서 적대적으로 훈련된 network의 사례에서, 우리는 표준적인 2000스텝의 Decision Boundary Attack(DBA) [4]와 PGD, 그리고 각각에 대해서 적대적으로 훈련된 모델을 평가하였다. 우리는 훈련에 사용된 $\\epsilon$의 값보다 작거나 같을 때, 성능이 크거나 같다는 것을 관찰하였다. MNIST에서는 짧은 진행 후 날카롭게 떨어졌다. 더욱이, MNIST에서 PGD를 사용한 $\\ell_2$-trained network의 성능이 좋지않고, 모델의 robustness를 크게 과대평가하고 있다는 것을 관찰했다. 이는 모델이 학습한 threshold filter가 loss 그레디언트를 masking하는 것에 기인할 가능성이 있다. (decision-based attack은 그레디언트를 이용하지 않는다.)우리는 훈련하는 동안 사용한 것보다 더 작은 $\\epsilon$의 경우, 예상과 같거나 더 높은 정확도를 달성하는 것을 관찰했다. MNIST에서, 학습된 threshold 연산자들이 훈련에 사용된 정확한 값의 $\\epsilon$에 맞추어질 가능성 때문에, 미세하게 큰 $\\epsilon$ 값들에서 robustness의 큰 하락이 있음을 알 수 있다. (Appendix C) 반면, CIFAR 10의 사례에서의 감쇠는 보다 부드러웠다.MNIST에서의 $\\ell_2$-bounded attack의 사례에서, PGD가 $\\epsilon=4.5$와 같이 꽤 큰 $\\epsilon$에도 불구하고, 적대적 예제를 찾지 못한다는 것을 발견했다. 이 $\\epsilon$의 값을 관점적으로 보기 위해, Appendix D의 [그림12]에서 해당하는 적대적 예제의 샘플들을 제공한다. 우리는 이러한 교란들이 이미지의 ground-truth label을 바꾸는 데 충분히 유의미하다는 것을 관찰하였고, 우리의 모델이 실제로 그렇게 robust할 것 같지 않았다. 실제로, 하위 연구 [20, 25]는 PGD가 사실 이 모델의 $\\ell_2$ robustness를 과대평가하고 있다는 것을 발견했다. 이러한 행동은 학습된 threshold filter(Appendix C)들이 그레디언트를 가리는 것과, PGD가 loss를 최대화하는 것에 대한 방해를 유발할 가능성이 있다. 모델의 그레디언트에 의존하지 않고 decision-based attack으로 모델을 공격하는 것은 모델이 $\\ell_2$-bounded attack에 대해 보다 더 크게 취약하다는 것을 드러낸다. 그럼에도 불구하고, $\\ell_\\infty$ trained model은 여전히 일반적인 모델에 비해서 $\\ell_2$공격에 대해 여전히 더 robust하다.6 관련된 연구들적대적 예제들에 대한 연구들이 많기 때문에, 가장 관련이 있는 논문들만 정리하였다. 우리의 기여와 비교하기 전에, robust optimization이 수십년동안 딥러닝의 주제 밖에서 연구되었음을 상기하자. 또한 적대적 ML 연구가 딥러닝의 광범위한 사용보다 앞선 것임에 주의하라.(Ian J Goodfellow, Jonthan Shlens, and Christian Szegedy. Explaining and harnessing adversarial examples (ICLR), 2015) 에서 적대적 훈련이 도입되었지만, adversary의 활용은 흔하지 않았다. 즉, 데이터 포인트 주변의 loss를 선형화하는데 의존하였다. 결과적으로, 모델은 부분적인 adversary에 대해서는 robust하였지만 iterative 공격이 활용된 정교한 adversary들에게는 완전히 취약하였다.또한 적대적 훈련에 대한 ImageNet에서의 최근의 연구(Alexey Kurakin, Ian J. Goodfellow, and Samy Bengio. Adversarial machine learning at scale (ICLR), 2017)는 model capacity가 적대적 훈련에 있어서 중요하다는 것을 밝혀냈다. 이 논문과 비교하면, 우리는 multi-step 방법 (PGD)으로 훈련하는 것이 이러한 adversary들에 대한 저항을 이끌어 낼 수 있다는 것을 밝혀냈다.또한, (Ruitong Huang, Bing Xu, Dale Schuurmans, and Csaba Szepesvari. Learning with a strong adversary. arXiv preprint arXiv:1511.03034, 2015.)와 (Uri Shaham, Yutaro Yamada, and Sahand Negahban. Understanding adversarial training: Increasing local stability of supervised models through robust optimization. Neurocomputing, 307:195–204, 2018.)에서 min-max optimization 문제의 버전이 적대적 훈련에서 고려되었다. 그러나, 앞서 이 논문들에서 언급된 결과와 본 논문 사이에는 세가지 중요한 차이점이 존재한다. 첫째, 저자들은 inner maximization problem이 해결하기 어렵다고 주장한 반면, 우리는 더욱 자세하게 loss surface를 조사하였고 randomly re-started projected gradien descent가 대조적인 퀄리티로 종종 솔루션에 수렴한다는 것을 발견하였다. 이는 inner maximiztion problem에서 충분히 좋은 솔루션을 얻는 것이 가능하다는 것을 보여주었으며, 심층 신경망이 적대적 예제에 대한 내성을 가질 수 있다는 증거로 제시된다. 둘째, 이들은 one-step adversary만을 고려하였지만, 우리는 multi-step method를 사용하여 연구하였다. 추가적으로, Uri Shaham 외 연구진들의 논문에서의 실험은 유망한 결과를 만들어냈지만 오직 FGSM에 대해서만 검증하였다. 그러나, FGSM만을 이용한 검증은 완전히 신뢰할 수 없다. 익서에 대한 증거 중 하나로는 Uri Saham외 연구진들의 분류기는 $\\epsilon=0.7$일 때 70%의 정확도를 산출하였지만, 각 픽셀을 $0.5$이상 교란할 수 있는 상대라면 균일하게 회색 이미지를 만들 수 있고, 따라서 이 분류기를 속일수 있다는 것이다.또한 (Florian Tramer, Nicolas Papernot, Ian Goodfellow, and Patrick McDaniel Dan Boneh. The space of transferable adversarial examples. In ArXiv preprint arXiv:1704.03453, 2017.)와 같은 더욱 최근의 연구에서는 transferability 현상을 조사하였다. 이 연구는 손실이 선형(에 가까운) 자연적인 예제들의 주변 지역에 집중되어 진행되었다. 큰 교란이 있을 때, 이 지역은 adversarial landscape의 완전한 picture를 주지 않는다. 이것은 우리의 실험에 의해 확인될 뿐만 아니라 Florian Tramer외 연구진들에 의해서도 지적되었다.7 결론우리의 발견은 심층신경망이 적대적 공격에 내성을 가질 수 있다는 증거를 제시한다. 우리의 이론과 실험이 가리키듯이, 우리는 신뢰할 수 있는 적대적 훈련 방법을 설계할 수 있다. 이것의 뒤에 있는 중요한 통찰중 하나는, 기본적인 최적화의 예상 외의 규칙적인 구조였다. 관련된 문제는 많은 뚜렷한 국소 최댓값을 갖는 고도로 non-concave 함수의 최대화에 해당하지만, 그 값들은 매우 집중되어 있다. 종합하자면, 우리의 발견은 adversarially robust한 딥러닝 모델이 현재 도달 범위 내에 있을 수 있다는 희망을 준다.MNIST 데이터셋에서, 우리의 network는 매우 robust하였고, 광범위하고 강력한 $l_\\infty$ bound adversaries와 큰 perturbation에 대해서 높은 정확도를 달성했다. CIFAR10 데이터셋에서의 실험은 아직 이러한 수준까지 도달하지 못하였다. 그러나, 우리의 결과는 우리의 기술이 network의 robustness의 중요한 향상을 이끌어 낸다는 것을 이미 보여주었다. 우리는 이러한 방향의 더 많은 탐구가 이 데이터셋의 adversarially robust network를 이끌어 낼 수 있으리라고 믿는다." }, { "title": "적대적 예제의 설명과 활용 (Fast Gradient Sign Method, FGSM) - Ian J.Goodfellow, Jonathan Shelens & Christian Szegedy", "url": "/posts/fgsm/", "categories": "ADVERSARIAL TRAINING, FGSM", "tags": "adversarial example", "date": "2022-07-28 15:00:00 +0900", "snippet": "의역 99%, 지적 태클 환영원문: Explaining and harnessing adversarial example초록신경망을 포함한 일부 머신러닝 모델들은 적대적 예제들을 일관적으로 오분류한다. 적대적 예제란, 데이터셋에서 미세하지만 의도적으로 worst-case 방향으로 교란(perturbation, 이하 교란)을 주어서 만든 입력값를 말한다. 이렇게 함으로써 모델은 높은 신뢰도(confidence, 동일한 측정대상을 측정하였을 때 일관성 있는 측정 결과를 산출하는 정도)로 잘못된 답을 내놓게 된다. 이러한 취약점은 원래 비선형성과 과적합에 집중되어 설명되고 있었는데, 우리는 이와 다르게 선형성에 있다고 주장할 것이다. 이는 새로운 수치적인 근거로 뒷받침되며, 최초로 모델의 아키텍처와 훈련 데이터셋을 아우르는 일반화(generalization)에 대한 흥미로운 설명을 제시할 것이다. 또한 이러한 관점에서 적대적 예제를 생성하는 간단하고 빠른 방법을 제시할 것이다. 이러한 방법을 이용한 예제들을 적대적 훈련에 이용한 결과, MNIST 데이터셋에서의 maxout network의 테스트셋에서의 에러를 줄일 수 있었다.개요Szegedy et al,. (2014b)는 SOA(State-Of-Art, 현존 최고 성능) 신경망을 포함한 일부 머신 러닝 모델들이 적대적 예제에 취약하다는 점을 발견했다. 즉 이러한 머신 러닝 모델들은 올바르게 분류된 예시에 미세한 변경만을 가해도 이것을 잘못 분류한다는 것이다. 서로 다른 아키텍쳐를 가진 다양한 모델 대부분이 동일한 적대적 예제를 오분류했다. 이는 적대적 예제가 현존 훈련 알고리즘이 근본적인 맹점(blind spot)을 가지고 있다는 것을 알려준다고 볼 수 있다.지금까지 위 현상의 원인은 미스테리였다. 신경망의 과도한 비선형성이 원인으로 제시 되었으며, 순수한 지도 학습 문제의 불충분한 model averaging과 불충분한 정규화, 그리고 신경망의 과도한 비선형성이 원인으로 추측되고 있었다. 우리는 이러한 가설이 필요없다는 것을 보여줄 것이다. 고차원 공간에서의 선형 행동은 위 현상의 원인이 되기에 충분하다. 이 관점을 통해 적대적 훈련을 실용화 할 수 있도록 적대적 사례를 생성하는 빠른 방법을 설계할 수 있다. 우리는 적대적 훈련이 드롭아웃(Srivastava et al., 2014)을 단독으로 사용함으로써 제공되는 것보다 더 많은 정규화 이점을 제공할 수 있음을 보여준다. 드롭아웃, 사전학습, model averaging과 같은 일반적인 정규화 전략들은 적대적 사례에 대한 모델의 취약점을 크게 없애주지 않는다. 그러나 RBF network와 같은 비선형 모델류로 바꾸는 것은 그렇게 할 수 있다.우리의 설명은 선형성으로 인한 모델 훈련의 용이성과 비선형성으로 인한 적대적 예제에 대한 모델의 내성 사이의 근본적인 균형을 제안한다. 장기적으로 더 많은 비선형 모델을 성공적으로 훈련시킬 수 있는 더 강력한 최적화 방법을 설계함으로써 이러한 trade-off를 피하는 것이 가능하다고 보고 있다.2 관련된 연구Szegedy et al,. (2014b)는 신경망과 관련된 모델들의 다양하고 놀라운 특징을 발견했다. 아래는 본문과 가장 연관된 연구들이다. Box-constrained L-BFGS can reliably find adversarial examples. On some datasets, such as ImageNet (Deng et al., 2009), the adversarial examples were so close to the original examples that the differences were indistinguishable to the human eye. The same adversarial example is often misclassified by a variety of classifiers with different architectures or trained on different subsets of the training data. Shallow softmax regression models are also vulnerable to adversarial examples. Training on adversarial examples can regularize the model—however, this was not practical at the time due to the need for expensive constrained optimization in the inner loop.이러한 결과는 현대 기계 학습 기술을 기반으로 한 분류기가 테스트 세트에서 우수한 성능을 얻는 분류기일지라도 올바른 출력 레이블을 결정하는 진정한 기본 개념을 학습하지 못하고 있음을 시사한다. 이들 알고리즘은 자연적으로 발생하는 데이터에는 잘 작동하지만, 데이터 분포에서 거의 발생하지 않는 입력을 주면 가짜인 것이 들통나는 포템킨 마을을 구축했다. 이것은 조금 실망스러운데, 왜냐하면 computer vision에서 인기있는 접근은 합성곱 신경망 feature를 지각 거리에서 유클리드 거리로 근사하는 공간으로 사용하는것이기 때문이다. 측정할 수 없을 정도로 작은 지각 거리를 가진 이미지가 네트워크 표현에서 완전히 다른 클래스에 해당한다면 이러한 유사성은 분명히 결함이 있다고 볼 수 있다.위 결과는 선형 분류기가 동일한 문제를 가지고 있음에도 특히 심층 신경망의 단점으로 해석되어왔다. 우리는 이러한 결함을 그것을 해결하여 모델의 성능을 향상 시킬 기회로 여기고 있다. 실제로 클-린한 입력에 대해 최신 정확도를 유지하면서 성공적으로 수행된 모델은 아직 없지만, Gu &amp; Rigazio(2014)와 Chalupka 등(2014)은 적대적 교란에 저항하는 모델을 설계하기 위한 첫 단계를 이미 시작했다.적대적 예제와 선형성에 대한 설명선형 모델에서의 적대적 예제의 존재부터 설명하겠다.많은 문제에서, 개별 입력 feature의 정밀도는 유한하다. 에를 들어 디지털 이미지는 픽셀 당 8비트을 사용하기 때문에, 1/255이하 크기인 모든 정보를 버린다. 이와 같이 feature들의 정밀도는 유한하며, 교란된 입력과 원래 입력의 차이가 정밀도 이하라면, 분류기가 입력 $x$와 교란된 적대적 예제$\\tilde{x}=x+\\eta$를 다른 클래스로 분류하는것은 타당하지 않다. 수식적으로, 균일하게 분포된 클래스를 분류하는 문제에서 $||\\eta||_\\infty&lt;\\epsilon$ 일 때, 분류기는 $x$와 $\\tilde{x}$를 같은 클래스로 분류할 것으로 기대된다. 이 때 $\\epsilon$은 저장 장치나 센서에게 무시될 수 있을 정도로 충분히 작은 값이다.이제 가중치 벡터 $w$와 적대적 예제 $\\tilde{x}$ 사이의 내적을 고려하자.\\[w\\cdot \\tilde{x}=w\\cdot x+w\\cdot \\eta\\]적대적 교란은 활성화 값을 $w\\cdot \\eta$ 만큼 증가 시킨다.$\\eta=sign(w)$로 설정함으로써 $\\eta$에 max norm constraint($sign((1, -2, 3))=(1, -1, 1),$ 이와 같이 벡터의 각 원소의 크기가 1로 변경 되어 최종 norm 크기가 제한된다)을 가하여, 이 증가를 최대화 할 수 있다. $w$ 가 $n$ 차원이고 가중치 벡터의 각 요소의 평균 크기가 $m$ 일 때, 활성화 값은 $mn$만큼 증가한다.$||\\eta||_\\infty$ 는 문제의 차원에 따라 증가하지 않지만, $\\eta$ 에 의한 교란으로 인한 활성화 값은 $n$ 에 따라 증가 할 수 있고, 고차원 문제라면 입력값에 수많은 무한소 변경을 가하여 출력값에 큰 변화를 줄 수 있다. 선형 모델은 여러 신호가 존재하고, 다른 신호들이 다른 신호들이 더욱 큰 진폭을 가졌더라도, 모든 가중치들에 가장 가까운 신호쪽으로 정렬되도록 강제된다. 이것을 “우발적 스테가노그래피 (accidental steganography)”라고 생각할 수 있다.위 설명은 단순 선형 모델에서 입력값이 고차원일 경우 적대적 예제를 가질 수 있음을 보여준다. 적대적 예제에 대한 기존의 설명들은 신경망의 고도의 비선형성등 과 같은 가정된 특징을 사용하였다. 그러나 선형성에 기반한 가설은 이보다 더 간단하며, softmax regression 이 왜 적대적 예제에 취약한지에 대해서도 설명할 수 있다. Softmax regression, $x$가 $768 \\times 1$ 이라면 교란됬을 때 출력의 변경이 유의미해질 수 있다.4 비선형 모델들의 선형 교란적대적 예제가 선형성 때문이라는 관점은 이것을 빠르게 생성하는 방법을 제공한다. 우리는 신경망이 적대적 예제에 저항하기에는 너무 선형적이라는 가설을 세웠다. LSTM, ReLUs, 그리고 maxout network는 모두 최적화하기에 용이하도록, 의도적에게 선형적으로 설계되었다. sigmoid network와 같은 모델들은 위와 같은 이유로 그들의 시간을 거의 non-saturating하거나 선형화하는데 쓰도록 세심히 튜닝되었다. 이러한 선형성은 모델을 쉽고, 분석적인 교란으로 손상 시킬 수 있게한다. [그림1] 빠른 적대적 예제 생성이 ImageNet의 GoogLeNet에 적용된 모습이다. 무시할 수 있을 만큼 작은 벡터를 cost function의 기울기와 부호를 동일하게 하여 더함으로써, GoogLeNet의 이미지 분류 결과를 바꿀 수 있다. 이 떄 GoogLeNet의 실수 변환 후 8비트 이미지 인코딩에서 가장 작은 비트의 크기(정밀도)는 $\\epsilon=0.007$일 때이다.모델의 파라미터를 $\\theta,$ 입력을 $x$, $x$에 따른 정답 레이블을 $y$라고 하고 신경망의 훈련에 사용하는 cost function을 $J(\\theta, x, y)$라고 하자. $\\theta$의 현재 값을 기준으로 비용함수를 선형화 할 수 있을 것이다. 또한 이때 다음과 같은 최적의 max-norm-contraint된 교란값 $\\eta$을 얻을 수 있다.\\[\\eta=\\epsilon sign(\\nabla_xJ(\\theta, x, y))\\]이것을 적대적 예제 생성의 “빠른 그레디언트 부호 방법(fast gradient($:=\\nabla_x$) sign($:= sign()$) method, FGSM)”이라고 칭한다. 이때 역전파를 사용하여 효율적으로 그레디언트를 계산할 수 있다.우리는 이 방법이 다양한 모델들의 오분류를 유발한다는 것을 확실하게 발견했다. [그림1]의 ImageNet에서의 시연을 참고하자. 이때 사용한 $\\epsilon=0.25$이다. 또한 우리는 MNIST 데이터셋에서 shallow softmax classifier가 79.3%의 신뢰도로 99.9%의 에러율을 내도록 유발하였다. 같은 세팅에서 maxout network는 우리의 적대적 예제들을 평균 신뢰도 97.6%로 89.4% 잘못 분류 하였다. 비슷하게, 마찬가지로, $\\epsilon=0.1$일 때, CIFAR-10 테스트 셋의 전처리된 버전에서 convolutional maxout network를 사용하였을 때 87.15%의 에러율과 잘못된 레이블에 할당될 평균 확률 96.6%를 얻었다. 적대적 예제를 생성하는 다른 쉬운 방법도 가능하다. 예를 들어, 입력 $x$를 그레디언트$(\\nabla_x J)$방향으로 작은 각도로 회전시키면 확실하게 or 안정적으로 (reliably) 적대적 예제를 생성할 수 있다.이러한 간단하고 저비용의 알고리즘이 오분류를 유발하는 적대적 예제를 생성할 수 있다는 것은 적대적 예제를 선형성의 결과로 해석하는 근거로 유리하게 작용한다. 이 알고리즘은 적대적 훈련 (적대적 예제를 모델 훈련에 사용하는 것)의 속도를 높이거나, 훈련된 모델의 분석에도 유용하다.5 선형 모델들의 적대적 훈련 vs 가중치 감쇠(WEIGHT DECAY) [그림2] logistic regrssion에 적용된 FGSM. 이 때 이것은 근삿값이 아니라 진짜로 max-norm box에서 가장 해로운 적대적 사례이다. a) MNIST 데이터셋에서 훈련된 logistic regression의 가중치들b) MNIST 데이터셋에서 훈련된 logistic regression의 가중치들의 부호. 이게 최적의 교란값이다. 모델이 low-capacity(파라미터의 개수, 용량)이고 잘 적합되지만, 이런 교란은 인간이 3과 7을 혼동하게 하기 어렵다.c) MNIST 데이터셋의 3들과 7들. logistic regression은 이 예제들을 3과 7로 분류하는 작업에서 1.6%의 에러율을 보였다.d) FGSM으로 생성한 적대적 예제들. $\\epsilon=0.25$로 하고 logistic regression에 적용하였다. 이 예제들의 logistic regression 모델의 에러율은 무려 99%이다.우리가 실험해볼 수 있는 가장 간단한 모델은 아마도 logistic regression일 것이다. 이 경우, FGSM이 적절하다. 이 사례를 이용해 간단한 환경에서 적대적 예제가 어떻게 생성되는지에 대한 직관을 얻어보도록하자. [그림2]의 이미지들을 참조하자.레이블 $y={-1, 1}$에서 $P(y=1)=\\sigma(w\\cdot x+b)$를 예측하는 단일 모델을 훈련한다고 가정하자. 이 때 $\\sigma(z)$는 logistic sigmoid function이다. 훈련은 다음과 같은 경사 하강으로 구성된다.\\[\\mathbb{E}_{x,y\\sim p_{data}}\\zeta(-y(w\\cdot x+b))\\]$x, y \\sim p_{data}$ : true data 분포 $p_{data}$ 속의 $x, y$$\\zeta(z)=\\log(1+\\exp(z))$인 softplus function이다. 아래와 같이 graident sign 교란에 기반하여, 원래 $x$ 대신 $x$의 최악의 적대적 교란에서 훈련하는 간단한 수식을 유도할 수 있다. 그레디언트의 부호는 $-sign(w)$이고, $w\\cdot sign(w)=||w||$임에 유의하라. 따라서 logistic regression의 적대적 훈련은 아래 수식을 최소화 하는 것이다.\\[\\begin{align*}&amp;\\quad \\ \\mathbb{E}_{x,y\\sim p_{data}}\\zeta(-y(w\\cdot \\tilde{x}+b)) \\\\ \\\\ &amp;= \\mathbb{E}_{x,y\\sim p_{data}}\\zeta(-y(w\\cdot (x-\\epsilon sign(w))+b))\\\\ \\\\&amp;=\\mathbb{E}_{x,y\\sim p_{data}}\\zeta(y(\\epsilon||w||-w\\cdot x-b))\\end{align*}\\]$L^1$ 정규화와 다소 유사해 보인다. 그러나 중요한 차이점들이 있다. 가장 중요한것은, $L^1$ 페널티는 훈련 비용에 추가되기 보다는, 훈련 중 모델의 활성화에서 차감된다. 이는 모델이 $\\zeta$를 포화시킬만큼 충분히 신뢰할 수 있는 예측을 한다면 결국엔 해당 페널티가 사라지기 시작한다는 것을 의미한다.이것이 일어난다고는 보장할 수 없다. underfitting 체제하에서는, 적대적 훈련은 단지 underfitting을 더욱 악화시킬 뿐이다. 따라서 $L^1$ weight decay를 적대적 예제보다 더 최악의 사례라고 볼 수 있다. 왜냐하면 good margin의 경우에서는 비활성화에 실패하기 때문이다.logistic regression을 넘어서 다중 분류 softm max regression의 경우, $L^1$ weight decay는 더욱 암울해진다. 왜냐하면 각 softmax의 출력을 독립적으로 교란될 수 있는 것으로 취급하기 때문이다. 실제로 모든 클래스의 가중치 벡터들과 맞춰서 조정할 수 있는 $\\eta$를 찾을 수 없다. Weight decay는 다중 hidden states의 심층 신경망의 경우 교란으로 발생할 수 있는 손실을 과대평가한다. 이와 같이 $L^1$ weight decay는 적대로 인한 손실을 과대평가하기 때문에, feature의 정밀도보다 더 작은 $L^1$ weight decay 계수를 사용하는 것이 필수이다. MNIST 데이터셋에서 maxout network를 훈련할 때, $\\epsilon=0.25$를 사용한 적대적 훈련에서 우리는 좋은 결과를 얻었다. 첫 번째 층에 $L^1$ weight decay를 적용했을 때, 0.0025의 계수조차도 너무 큰 것을 발견하였다. 또한 트레이닝 셋에서 5% 이상의 에러율을 유발하여 모델을 고착시켰다. 더 작은 weight decay 계수가 성공적인 훈련을 할 수 있게 해주지만, 정규화 효과는 없었다.위 단락은 뭔말인지 이해할 수 없었다. 아래 원문 참조If we move beyond logistic regression to multiclass softmax regression, $L^1$ weight decay becomes even more pessimistic, because it treats each of the softmax’s outputs as independently perturbable, when in fact it is usually not possible to find a single $\\eta$ that aligns with all of the class’s weight vectors. Weight decay overestimates the damage achievable with perturbation even more in the case of a deep network with multiple hidden units. Because $L^1$ weight decay overestimates the amount of damage an adversary can do, it is necessary to use a smaller $L^1$ weight decay coefficient than the associated with the precision of our features. When training maxout networks on MNIST, we obtained good results using adversarial training with $\\epsilon=.25$. When applying $L^1$ weight decay to the first layer, we found that even a coefficient of .0025 was too large, and caused the model to get stuck with over 5% error on the training set. Smaller weight decay coefficients permitted succesful training but conferred no regularization benefit.6 신경망의 적대적 훈련적대적 예제에 대한 취약성으로 인한 심층 신경망의 비판은 다소 오해가 있다. 얕은 선형 모델들과 달리, 심층 신경망은 적어도 적대적 교란에 대항하는 함수를 표현 할 수 있다. The universal approximator theorem (Hornik et al ., 1989)는 충분한 수의 유닛들이 있는, 적어도 하나의 hidden layer을 가지고 있는 신경망은 임의의 정확도로 어떠한 함수라도 표현할 수 있음을 보장한다. 얕은 선형 모델은 training points 부근에서 일관될 수 없는 반면, 다른 training points에서 다른 출력을 할당할 수 있다.당연하게도, the universal approximator theorem은 훈련 알고리즘이 모든 목적에 대응하는 함수를 표현 할 수 있다고 말하지는 않았다. 명백하게, 표준적인 지도 훈련은 적대적 예제에 내성을 가지는 함수가 있다는 것을 명시하지 않는다. 이것은 따로 훈련 과정에 포함시켜야 한다.Szegedy et al,. (2014b)는 깨끗한 예제와 적대적 예제의 혼합으로 한 훈련에서, 신경망이 다소 정규화가 될 수 있다는 것을 보였다. 적대적 예제에서 훈련시키는 것은 다른 data augmentation 방법들과는 다소 차이가 있다. 일반적으로 테스트셋에서 실제로 있을 것 같은, 번역등과 같은 변환으로 데이터를 보강(augments)한다. 이와 달리, 적대적 예제의 data augmentation은 자연적으로 발생할 것 같지 않은, 즉 모델 의사 결정 기능 방식의 결함을 파헤치는 입력을 사용한다. 기존에 이러한 과정은 벤치마크에서 drop out을 넘어서는 성능개선으로 입증된 적이 없었다. 그러나 부분적으로, 이는 L-BFGS에 기반한 고비용의 적대적 사례로 광범위하게 실험하는 것이 어렵기 때문이다.우리는 FGSM에 기반한 아래와 같은 적대적 목적 함수가 효과적인 정규화장치라는 것을 발견했다.\\[\\tilde{J}(\\theta, x, y)=\\alpha J(\\theta, x, y)+(1-\\alpha)J(\\theta, x+\\epsilon sign(\\nabla_x J(\\theta, x, y))\\]우리는 모든 실험에서 $\\alpha=0.5$로 설정하였다. 다른 값이 더 나을 수 있다. 우리는 이 모수에 대한 초기 설정이 충분히 잘 작동하여 더 나은 값을 찾을 필요를 느끼지 못하였다. 위와 같은 접근 방식은 현제 모델에 저항하기 위하여, 지속적으로 적대적 예제들을 갱신한다는 것을 의미한다. drop out으로 정규화된 maxout network에 이 접근 방식을 사용한 결과, 적대적 훈련을 하지 않았을 때 에러율 0.94% 에서 적대적 훈련을 했을 때 에러율 0.84%로 줄일 수 있었다.우리는 훈련 세트의 적대적 예제에 대한 오류율이 0이 되지 않는 것을 관찰했다. 우리는 이 문제를 두 가지의 변화를 줌으로써 해결했다. 첫째로, 모델의 크기를 키웠다. 이 문제 때문에 레이어당 240개의 유닛을 사용하는 원래 maxout network대신 레이어당 1600개의 유닛을 사용하였다. 적대적 훈련이 없다면 이것은 살짝 과적합을 유발하며, 테스트셋에서 1.14%의 오류율을 얻었다. 적대적 훈련하에서, 검증 셋의 에러가 매우 느리게, 점진적으로 수평을 이루는 것을 발견했다. 기존 maxout network의 결과는 early stopping을 이용하였고, 검증 셋의 에러율이 100에폭동안 감소하지 않는다면 학습을 종료하였다. 우리는 검증셋의 에러가 매우 평평한 반면, 적대적 검증 셋은 그렇지 않다는 것을 발견하였다. 따라서 우리는 적대적 검증셋에 early stopping을 적용하였다. 훈련할 에폭의 수를 결정하기 위해 이러한 평가 기준(criterion)을 사용하였고, 60000개의 예제에 대하여 다시 훈련시켰다. 훈련 데이터의 미니 배치, 모델 가중치 초기화, drop out mask 생성에 난수 생성시를 사용한 서로 다른 seed들의 5개의 훈련에서, 테스트셋에서의 에러율은 0.77%이 4개, 나머지 하나에서 0.83%의 에러율이 나왔다. 이 0.782%의 평균은 MNIST의 순열 불변 버전에 대해 알려진 최상의 결과이다. 단, 0.79%로 DBM을 미세 조정하여 얻은 결과와 통계적으로 구별할 수 없다(Srivastata et al., 2014). [그림 3] MNIST 데이터셋에서 훈련된 maxout network 가중치들의 시각화. 각 행은 단일 maxout 유닛의 filter를 나타낸다. 왼쪽은 일반적으로 훈련된 모델이고, 오른쪽은 적대적 훈련된 모델이다.이 모델은 또한 적대적 예제에 대한 내성을 다소 가진다. 적대적 훈련없는 이러한 종류의 모델이 FGSM의 적대적 예제에서 89.4%의 에러율을 보였다는 것을 상기하자. 적대적 훈련과 함께한다면, 이 에러율이 17.9%로 떨어진다. 각각의 모델들이 생성한 적대적 예제들은 두 모델 간에 전송될 수 있지만, 적대적 훈련된 모델이 더 robustness함을 보여준다. 기존 모델을 통해 생성된 적대적 예제는 적대적 훈련 모델에서 19.6%의 에러율을 보였지만, 적대적 훈련 모델에서 생성된 적대적 예제는 기존 모델에서 40.9%의 에러율을 나타냈다. 적대적 훈련 모델이 적대적 예제를 잘못 분류할 경우, 불행하게도 그 예측은 여전히 높은 신뢰도를 갖는다. 오분류된 예제들의 평균 신뢰도는 81.4%였다. 우리는 또한 일반적으로 학습된 모델의 가중치가 적대적 훈련을 할 경우 크게 변경되며, 적대적 훈련 모델의 가중치가 상당히 더 국소화되고 해석 가능하다는 것을 발견했다(그림 3 참조).이 적대적 훈련 과정은 데이터가 상대방(adversary)에 의해 교란되었을 때 최악의 예제의 에러를 최소화 시키는 것처럼 보일 수 있다. 이것은 학습을 하기 위해 적대적 게임을 하는 것, 또는 $U(-\\epsilon, \\epsilon)$ 범위의 노이즈가 섞인 샘플들을 입력에 추가했을 때 기대되는 cost의 상계를 최소화하는 것으로 해석될 수 있다. 또한 적대적 훈련은 모델이 스스로 새로운 지점에서의 레이블을 유추하는 능동적인 학습으로 볼 수 있다. 이 경우 인간 labeler는 nearby points에서 label을 복사하는 휴리스틱 labeler로 대체된다.또한 $\\epsilon$ max norm box의 모든 포인트들 혹은 box 내의 많은 점들을 샘플링하여 훈련을 실시함으로써 feature의 $\\epsilon$ 정밀도 이하 변화에 둔감해지도록 정규화할 수 있다. 이는 훈련 중에 max norm $\\epsilon$의 노이즈를 추가하는 것과 관련있다. 그러나, 평균과 공분산이 0인 노이즈는 적대적 예제를 예방하는 데 매우 비효율적이다. 참조된 어떠한 벡터와 해당 노이즈와의 내적의 기댓값은 0이다. 이는 많은 경우에 해당 노이즈가 더 복잡한 입력을 만들 뿐, 아무런 효과가 없다는 것을 의미한다.실제로 대부분의 경우 이런 노이즈는 낮은 목적함숫값을 만들어낸다. 적대적 훈련은 분류에 강하게 저항하는 노이즈 포인트들을 고려함으로써 더욱 효율적으로 훈련하기 위해 노이즈가 있는 입력들에서 어려운 예제들을 마이닝 하는 것이라고 볼 수 있다. 제어 실험으로써 각 픽셀에 무작위로 $\\pm \\epsilon$을 하거나, $U(-\\epsilon, \\epsilon)$의 노이즈를 섞어서 maxout network를 훈련시켜 보았다. 이것은 신뢰도 97.3%의 신뢰도의 86.2%의 에러율을 나타내었고, FGSM으로 생성된 적대적 예제들은 신뢰도 97.8%로 90.4%의 에러율을 나타내었다.$sign$함수의 미분이 0이거나 어디에서도 정의되지 않기 때문에, FGSM 기반 적대적 목적 함수의 경사하강법은 모델이 파라미터의 변화에 따라 상대방이 어떻게 대응할 지 예측할 수 없게 한다. 대신 작은 회전이나, scaled gradient의 덧셈을 기반으로 한 적대적 예제를 사용한다면, 교란 과정 자체가 미분가능하고 학습 과정에서 상대방에게 대응할 수 있을 것이다. 그러나, 이러한 적대적 예제는 해결하기가 어렵지 않기 때문에 정규화 시킬만큼 강력한 것을 발견하지 못했다.하나의 자연스러운 질문은 입력을 교란하는 것이 더 나은가 혹은 hidden layer를 교란하는 것이 나은가, 아니면 둘 다 교란하는 것이 나은가이다. 여기에서는 결과과 일정하지 않다. Szegedy et al,. (2014b)는 적대적 교란은 hidden layer들에 적용됬을 때 최고의 정규화를 제공한다는 것을 보고했다. 이 결과는 sigmoidal network에서 얻어졌다. 우리의 FGSM를 사용한 실험에서 활성화가 유계이지 않은 hidden units의 network는 그들의 hidden unit 활성화를 매우 크게함으로써 단순히 반응한다는 것을 발견했다. 따라서 원래 입력에 교란을 주는 것이 일반적으로 더 낫다.Rust 모델과 같은 saturating 모델들에서는 교란된 입력이 hidden layer의 교란과 유사하게 수행된다는 것을 발견했다. hidden layer를 회전하는 것에 기반한 교란은 유계이지 않은 활성화가 발산하여 추가적인 교란을 비교에 의해 작게 만드는 문제를 해결했다.hidden layer의 회전 교란으로 maxout network를 성공적으로 훈련 시킬 수 있었다. 그러나 이는 input layer에 교란을 더하는 것만큼의 강력한 정규화 효과를 산출해내지 못했다. 적대적 훈련에 대한 우리의 관점은 모델이 적대적 예제에 저항하는 것을 학습할 수 있을 만한 capacity가 있을 때만 유용하다는 것이다. 이것은 universal approximator theorem이 적용되는 경우에만 선명하게 적용된다. 신경망의 마지막 layer인 linear sigmoid, linear softmax layer는 최종 hidden layer 함수에 대한 universal approximation이 아니기 때문에, 최종 hidden layer에 적대적 교란을 적용했을 때 underfitting의 문제에 직면할 수 있다. 실제로 우리는 이 효과를 발견했다. hidden layer의 교란을 사용한 훈련의 최고의 결과는 최종 hidden layer에 교란을 주지 않는다.7 모델 CAPACITY 의 다른 종류들적대적 예제의 존재가 직관에 맞서는 것처럼 보이는 이유 중 하나는 우리는 대부분 고차원 공간에서 거지같은 직관(poor intuitions)을 가지고 있기 때문이다. 우리는 3차원 공간에서 살고 있고, 따라서 수백개의 차원에서의 작은 변화가 더해져서 하나의 큰 효과를 발휘하는 것에 익숙하지 않다. 우리의 거지같은 직관이 미쳐 날뛰는 일이 하나 더 있다. 많은 사람들이 low-capacity의 모델들은 다양하고 신뢰도의 예측을 할 수 없을 것이라고 생각한다. 이것은 잘못된 생각이다. low capacity의 몇 모델들은 이러한 동작을 한다. 예를 들어 다음과 같은 얕은 RBF network를 사용해보자.\\[p(y=1|x)=\\exp((x-\\mu)\\cdot \\beta(x-\\mu))\\]이는 $\\mu$ 근방에 양의 클래스가 존재한다고 높은 신뢰도로 예측할 수 있을 뿐이다. 다른 곳에서는 기본적으로 클래스가 없거나 신뢰도가 낮은 예측을 한다.RBF network는 자신이 속았을(fooled) 때 낮은 신뢰도를 가지고 있어, 적대적 예제에 근본적으로 면역이라고 할 수 있다. hidden layer가 없는 얕은 RBF network는 MNIST 데이터셋에 $\\epsilon=0.25$로 FGSM이 생성한 적대적 예제 에서 55.4%의 에러율을 보인다. 그러나, 이 모델이 오분류한 예제에서의 신뢰도가 오직 1.2%이며, 클-린한 예제에 대한 평균 신뢰도는 60.6%이다. 우리는 이러한 낮은 capacity의 모델이 공간의 모든 지점에서 올바른 답을 도출할 수 있을 것이라고 기대할 수 없다. 그러나 이것은 모델이 “이해하지 못한” 지점을 고려하여 신뢰도를 상당히 낮춰 올바른 반응을 한다.불행히도, RBF 유닛들은 유의미한 변환에 쉽게 반응하기 때문에, 잘 일반화되지 않는다. 우리는 선형 유닛들과 RBF 유닛들을 precision-recall tradeoff 곡선의 다른 점들로 볼 수 있다. 선형 유닛들은 특정 방향의 모든 입력에서 높은 recall 을 달성하지만, 낮선 상황에 너무 예민하게 반응하여 낮은 precision을 가질 수 있다. RBF 유닛들은 공간의 특정 지점에만 반응하여 높은 precision을 달성하지만, 그렇게 함으로써 recall을 희생한다. 이러한 아이디어르 바탕으로, 우리는 심층 RBF network를 포함하여 2차(quadratic) 유닛들과 관련된 다양한 모델을 탐구하기로 결정했다. 우리는 이것이 어려운 작업이라는 것을 발견했다. 적대적 교란에 저항 할 수 있을 만큼의 2차 억제를 가진 모든 모델은 SGD로 훈련할 때 높은 훈련 셋 에러를 얻었다.8 적대적 예제가 왜 일반화(Generalize)되는가?적대적 예제의 흥미로운 측면은 어떠한 모델을 위해 생성된 예제가 다른 모델들에 의해 오분류된다는 점이다. 그들이 서로 다른 아키텍쳐 혹은 상호배타적인(disjoint) 트레이닝 셋에서 훈련됬을지라도 말이다. 더욱이, 이 서로 다른 모델들이 적대적 예제를 오분류할 때, 그들은 종종 그것의 클래스에 대해 서로 동의한다. 고도의 비선형성과 과적합의 기반한 설명들은 이러한 행동에 대응하지 못한다. 왜 고도의 비선형성과 넘치는 capacity를 가진 다중 분류 모델이 일반적인 분포에서 벗어난 데이터를 같은 방식으로 일관적이게 분류하는가? 이러한 행동은 적대적 예제가 실수 속의 유리수처럼 공간을 미세하게 타일링한다는 가설의 관점에서 볼 때 특히 놀라운데, 이는 적대적 예제는 일반적이지만 매우 정확한 위치에서 나타나기 때문이다. [그림 4] 다양한 값의 $\\epsilon$에 따라서, 올바른 방향으로 움직인다면 $\\epsilon$의 거의 모든 충분히 큰 값에 대해 적대적 예제가 안정적으로 발생한다. 올바른 분류들은 $x$가 발생하는 데이터속의 얇은 다양체안에서만 일어난다. $\\mathbb{R}^n$공간의 대부분은 적대적 예제와 rubbish class 예제들로 구성되어 있다. 이 그림은 일반적으로 훈련된 maxout network로부터 만들어졌다. 왼쪽의 그림은 하나의 입력 예제에 $\\epsilon$을 변화시킬 때 10개의 MNIST 클래스 각각에 대한 소프트 맥스 계층의 인수를 보여준다. 올바른 클래스는 4이다. 각 클래스에 대한 정규화되지 않은 로그 확률들은 $\\epsilon$과 함께 눈에 띄게 선형이며 오분류는 $\\epsilon$값의 넓은 영역에서 안정적이라는 것을 알 수 있다. 더욱이, rubbish 입력의 체제로 이동할 수 있을 만큼 충분히 $\\epsilon$을 증가시킨다면 예측은 매우 극단적이게 된다. 오른쪽 그림은 곡선을 생성하는 데 사용되는 입력이다. 이 그림의 왼쪽 위는 $-\\epsilon$을 사용하였고, 오른쪽 아래는 $+\\epsilon$을 사용하였다. 노란색 상자는 올바르게 분류된 입력을 나타낸다.핑크색 실선은 올바르게 분류된 데이터의 분포이고, 다른 색의 점선들은 특정 클래스로 오분류한 적대적 예제들의 분포이다. 이외의 공간은 쓰레기 입력이다.선형적인 관점에서 적대적 예제는 넓은 부분집합들 안에 나타난다. 방향(direction) $\\eta$는 오직 비용 함수의 그레디언트와의 양의 내적을 필요로 하며, $\\epsilon$은 충분한 크기만이 요구된다. [그림 4]는 이러한 현상을 보여준다. $\\epsilon$의 다양한 값들을 추적함으로써, 적대적 예제가 미세한 주머니가 아닌 FGSM으로 정의된 1-D 부분 공간의 연속적인 영역에서 발생한다는 것을 알 수 있다. 이는 적대적 예제가 무수히 많으며, 왜 한 모델이 오분류한 적대적 예제를 다른 모델이 상당히 높은 확률로 오분류하는지를 보여준다.왜 다중 분류기들이 적대적 예제들을 같은 클래스로 분류하는지를 설명하기 위해, 우리는 현재의 방법론으로 훈련된 모든 신경망이 동일한 훈련 세트에서 학습된 선형 분류기와 유사하다는 가정을 했다. 기계 학습 알고리즘이 generalize할 수 있기 때문에, 이 분류기는 훈련 세트의 다른 부분집합에 대해서 훈련하여도 거의 동일한 분류 가중치를 학습 할 수 있다. 이러한 분류기 가중치의 안정성은 적대적 예제의 안정성 또한 초래한다.이런 가정을 시험해 보기위해, 우리는 심층 maxout network에서 적대적 예제들을 생성하였고, 이 예제들을 얕은 softmax network와 얕은 RBF network로 분류하였다. maxout network가 오분류한 예제들에서, RBF network는 maxount network가 예측한 클래스랑 16%만큼 일치한 반면, softmax network는 54.6%가 일치하였다. 그러나 이러한 수치는 모델마다 다른 에러율에 의해 크게 좌우된다. 비교되는 두 모델이 오분류하는 사례들에 주의를 기울이지 않으면, softmax regression은 maxout이 예측한 클래스랑 84.6%일치하는 반면, RBF network는 maxout이 예측한 클래스랑 오직 54.3%만이 일치했다. 비교를 위해서, RBF network는 softmax regression의 클래스를 53.6% 예측할 수 있었다. 따라서 이는 동작 속에 강한 선형 구성요소를 가지고 있다고 볼 수 있다. 우리의 가설은 maxout network의 오분류 혹은 generalize across models 하는 오분류에 대해 모든 것을 설명하지 않는다. 그러나 이 중 상당한 비율은, cross-model generalization의 주 원인이 되는 선형적 행동과 일치한다.9 다른 가설에 대한 반박여기서는 적대적 예제의 존재에 대한 일부 대안 가설을 고려하고 반박할 것이다.첫째로, generative training이 훈련 과정에서 더욱 많은 제약을 줄 수 있다거나, 모델이 가짜 데이터에서 진짜를 구별하는 것을 학습하는 것을 가능하게하며 진짜 데이터에서만 높은 신뢰도를 가질 수 있게 한다는 가설이다. The MP-DPM(Goodfellow et al,. 2013a)에 이 가설을 시험할 수 있는 좋은 모델이 있다. 이 모델의 추론 과정은 미분가능하며, MNIST 데이터셋에서 좋은 분류 정확도를 얻는다. (에러율 0.88%) 추론 과정이 미분 불가능한 다른 모델은 적대적 예제를 계산하기 힘들거나, MNIST 데이터셋에서 좋은 분류 정확도를 얻기 위해 별도의 non-generative discriminator 모델을 필요로 한다. MP-DPM의 사례에서는 generative 모델 자체가 위에 있는 non-generative 분류기 모델보다 적대적인 예에 반응하고 있다는 것을 확신할 수 있다. 우리는 이 모델이 적대적 예제에 취약하다는 것을 발견했다. $\\epsilon=0.25$일 때, MNIST 테스트 셋에서 생성된 적대적 예제의 에러율은 97.5%였다. 다른 형태의 generative 훈련이 내성을 가질 수 있게 한다는 것은 여전히 가능하지만, generatvie라는 사실만으로는 분명히 충분하지는 않다.적대적 예제의 존재에 대한 다른 가설은 개별 모델이 기복이 있을지라도 여러 모델을 평균화하면 적대적 사례를 극복할 수 있다는 것이다. 이 가설을 시험해보기 위해, 우리는 MNIST 데이터셋에서 20개의 maxout network를 훈련시켜 보았다. 각각의 network는 가중치 초기화, drop out mask 생성, stochastic gradient descent를 위한 미니배치 선택을 위해 서로 다른 난수 생성 seed를 사용하였다. 이 앙상블은 전체를 교란시키도록 설계된 $\\epsilon=0.25$의 적대적 예제들에서 91.1%의 에러율을 보였다. 오직 하나의 개별 모델을 교란시키도록 만들어진 적대적 예제에서는 에러율은 87.9%로 떨어진다. 따라서, 앙상블은 적대적 교란에 대해 단지 제한적인 저항만을 제공한다.10 요약과 결론본 문서는 다음과 같은 관찰로 요약할 수 있다. 적대적 예제는 고차원 내적의 성질로 설명될 수 있다. 이는 모델의 비선형성 때문이 아니라, 선형성의 의한 결과이다. 서로 다른 모델들에서 적대적 예제들이 일반화되는 점은 모델의 가중치 벡터의 높은 경향으로 설명된다. 서로 다른 모델일지라도 동일한 작업을 위해 훈련되었다면 유사한 함수를 학습한다. 공간의 특정 지점보다는 교란의 방향이 중요한다. 공간은 적대적 예제로 가득차 있는 것이 아니라, 유리수처럼 실수를 미세하게 타일링한다. 교란의 방향이 중요하기 때문에, 적대적 교란은 서로 다른 클-린한 입력에서 일반화될 수 있다. 적대적 예제를 생성하는 빠른 방법들의 종류들을 소개했다. 적대적 훈련이 drop out 보다 더욱 정규화를 수행한다는 것을 입증했다. 우리는 $L^1$ weight decay와 노이즈를 추가하는 것을 포함한 단순하지만 덜 효율적인 regularize로 제어 실험을 하여, 이들로는 적대적 훈련의 정규화를 따라잡을 수 없다는 것을 보였다. 최적화하기 쉬운 모델은 교란하기도 쉽다. 선형 모델은 적대적 교란에 저항할 능력이 부족하다. hidden layer를 사용한 구조 (the approximateor theorem이 적용된)만이 적대적 교란에 대한 내성을 학습할 수 있다. RBF network는 적대적 예제에 내성이다. 입력의 분포를 모델링하도록 훈련된 모델은 적대적 예제에 저항 할 수 없다. 앙상블로는 적대적 예제에 저항 할 수 없다.rubbish class 예제와 같은 일부 추가 관찰 사항은 부록에 수록하였다. rubbish class 예제는 어디에나 있고 쉽게 만들 수 있다. 얕은 선형 모델은 이런 rubbish class에도 저항 할 수 없다. RBF network는 rubbish class에 저항할 수 있다.Gradient-based optimization은 모-던 AI의 주류이다. 충분히 선형적으로 설계된 network(ReLU, maxout network, LSTM, sigmoid network that has been carefully configured not to saturate too much)는 우리가 신경쓰는 거의 대부분의 문제에 대해서, 최소한 훈련셋에서 적합할 수 있게 하였다. 적대적 예제의 존재는 데이터를 설명할 수 있거나, 테스트 데이터를 올바르게 분류하는 것이 그렇게 동작하도록 요구한 작업을 진정으로 이해하고 있지 않다는 것을 시사한다. 대신 그들의 선형적인 반응은 데이터 분포에서 나타나지 않는 지점에서 과도한 신뢰도를 보였고, 이 신뢰도의 예측은 종종 높은 부정확도를 보인다. 본 연구는 이 문제를 문제점을 명확하게 지적하고 각 문제를 수정함으로써 부분적으로 해결하였다. 그러나 어떤 이는 우리가 지금껏 사용한 모델들이 본질적으로 결함이 있다고 결론 낼 수도 있다. 최적화의 용이성은 이러한 결함으로 대가를 치르고 있다. 이는 국소적으로 안정적인 동작을 하는 모델을 훈련시킬 수 있는 최적화 과정의 개발에 동기부여를 한다." }, { "title": "4 빅 데이터 - 그레디언트 부스팅 vs XGBoost", "url": "/posts/gb-vs-xgb/", "categories": "XGB FOR GRADIENT BOOSTING, GRADIENT BOOSTING", "tags": "gradient boosting, XGBoost", "date": "2022-06-02 19:03:00 +0900", "snippet": "현실 세계의 데이터셋은 매우 거대하며 수조 개의 데이터 포인트로 이루어질 수 있다. 컴퓨터 한 대의 자원은 제약되어 있기 때문에 한 대의 컴퓨터로만 작업하는 것은 단점이 될 수 있다. 빅 데이터를 다룰 때 종종 병렬 컴퓨팅으 활용하려고 클라우드를 사용한다.대용량 데이터셋은 계산의 한계를 넘어설 때가 있다. 지금까지 사용한 데이터셋은 수만 개의 행과 수 백개 이하의 열로 이루어져 있다. 실행시간이 오래걸리지 않아 오류가 발생하지 않을 것이다.이번에는 외께 행성 데이터셋을 사용할 것이다. 이 데이터셋은 5087개의 행과 3189개의 열로 구성된다. 별의 생명 주기 동안에 빛의 밝기를 기록한 것이다. 행과 열의 개수를 곱하면 1500만 데이터 포인트가 된다. 100개의 트리를 사용한다면 모델을 구축하기 위해 15억개 데이터 포인트를 처리해야 한다.4.1 외계 행성 데이터셋 소개외계 행성 데이터셋은 2017년 캐글에 소개된 데이터셋이다. 이 데이터셋에는 별의 밝기에 대한 정보가 포함되어 있다. 각 행은 하나의 별에 대한 정보를 나타내며 각 열은 시간에 따라 밝기의 변화를 저장하고 있다. 밝기 외에도 LABEL 열에는 별이 외계 행성을 가지고 있으면 2 아니면 1로 레이블되어 있다.이 데이터셋은 수천 개의 별의 밝기를 담고 있다. 별의 밝기(light flux)는 종종 광속(luminous flux)이라고도 부르며 감지된 별의 밝기이다.별의 밝기가 주기적으로 달라질 때 외계 행성이 이 별을 공전하고 있을 가능성이 있다. 외계 행성이 별의 앞을 지나갈 때 빛의 일부분을 가리고 이로 인해 별의 밝기가 약간 감소된다고 가정한 것이다.외계 행성 데이터셋을 로드하고 머신러닝 작업을 위해 전처리 해보자.4.2 GB vs XGB데이터 전처리import pandas as pddf = pd.read_csv('./exoTrain.csv')from sklearn.model_selection import train_test_splitX = df.iloc[:, 1:]y = df.iloc[:, 0]X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=2)속도 비교import time# 그래디언트 부스트 모델# 시작 시간 저장start = time.time()gbr = GradientBoostingClassifier(n_estimators=100, max_depth=2, random_state=2)gbr.fit(X_train, y_train)y_pred = gbr.predict(X_test)score = accuracy_score(y_pred, y_test)print(f'accuracy: {score}')# 종료 시간 저장end = time.time()print(f'runtime: {end-start} sec')accuracy: 0.9874213836477987runtime: 294.03440713882446 sec# XGBoost 모델# 시작 시간 저장start = time.time()xg_reg = XGBClassifier(n_estimators=100, max_depth=2)xg_reg.fit(X_train, y_train)y_pred = xg_reg.predict(X_test)score = accuracy_score(y_pred, y_test)print(f'accuracy: {score}')# 종료 시간 저장end = time.time()print(f'runtime: {end-start} sec')accuracy: 0.9913522012578616runtime: 53.40976548194885 sec코랩 기준 XGBoost가 대략 3배 정도 빠르다. 또한 0.5%더 정확하다.(Imbalaced data라 의미없음)" }, { "title": "3 그레디언트 부스팅 하이퍼파라미터 튜닝", "url": "/posts/gb-hptunning/", "categories": "XGB FOR GRADIENT BOOSTING, GRADIENT BOOSTING", "tags": "gradient boosting", "date": "2022-06-02 19:02:00 +0900", "snippet": "이번에는 가장 중요한 그레디언트 부스팅의 매개변수인 learning_rate과 모델의 트리 개수 또는 반복인 n_estimators에 초점을 맞출 것이다.또한확률적 그레디언트 부스팅(stochastic gradient boosting)을 만드는 subsample 매개변수도 알아볼 것이다.그리고 RandomizedSearchCV를 통해 XGBoost와 결과를 비교해보겠다.3.1 Learning_rate이전에 GradientBoostingRegressor의 learning_rate 매개변수 값을 1.0에서 사이킷런 기본값인 0.1로 바꾸어서 성능을 크게 높였었다.learning_rate은 모델 구축에 너무 큰 영향을 끼치지 않도록 개별 트리의 기여를 줄인다.이를축소(shrinkage)라고도 부른다.이 매개변수를 주의 깊게 조정하지 않고 기본 학습기의 오차를 기반으로 전체 앙상블을 만들면 모델에 처음 추가된 트리의 영향이 너무 크게 된다.learning_rate은 개별 트리의 영향을 제한한다. 일반적으로 트리의 개수인 n_estimators를 늘리면 learning_rate은 줄여야 한다.최적의 learning_rate 값을 결정하는 것은 n_estimators에 따라 다르다. 먼저 n_estimators를 고정하고 learning_rate의 효과를 확인해보자. learning_rate을 0에서 1까지 바꾸어보자. learning_rate=1이면 트리 결과에 어떠한 조정도 하지 않는다는 의미이다. 기본값 0.1은 트리의 영향을 10%로 줄인다는 말이다.learning_rate_values = [.001, .01, .05, .1, .15, .2, .3, .5, 1.0]for value in learning_rate_values: gbr = GradientBoostingRegressor(max_depth=2, n_estimators=300, random_state=2, learning_rate=value) gbr.fit(X_train, y_train) y_pred = gbr.predict(X_test) rmse = MSE(y_test, y_pred)**.5 print(f'lr: {value}, RMSE: {rmse}')lr: 0.001, RMSE: 1633.0261400367258lr: 0.01, RMSE: 831.5430182728547lr: 0.05, RMSE: 685.0192988749717lr: 0.1, RMSE: 653.7456840231495lr: 0.15, RMSE: 687.666134269379lr: 0.2, RMSE: 664.312804425697lr: 0.3, RMSE: 689.4190385930236lr: 0.5, RMSE: 693.8856905068778lr: 1.0, RMSE: 936.3617413678853출력에서 볼 수 있듯이 기본 learning_rate 값 0.1이 300개의 트리에서 가장 좋은 성능을 낸다.이번에는 n_estimators를 바꾸어 보자. 위의 코드에서 n_estimators를 30, 300, 3000으로 바꾸고 learning_rate에 대한 RMSE 그래프를 그리면 다음과 같다.결과에서 보듯이 30개 트리를 사용하는 경우 learning_rate=0.3 근처일 때 최상의 성능을 낸다.300개의 트리를 사용할 때 그래프를 그려보자.learning_rate=0.1일 때 최소임이 잘 나타난다.이제 3000개의 트리를 사용하는 경우 learning_rate 그래프를 그려보자.3000개 트리를 사용하는 경우 learning_rate이 0.01일 때 최상의 점수를 낸다.이 그래프들은learning_rate과 n_estimator 매개변수를 함께 튜닝해야 한다는 점을 알려준다.3.2 기본 학습기그레디언트 부스팅의 회귀 모델의 기본학습기는결정트리이다. 이 결정 트리를 미세 튜닝할 필요는 없지만 정확도를 높이기 위해 매개변수를 조정 할 수 있다.예를 들어, 다음처럼 max_depth를 1,2,3,4로 바꾸면서 결과를 비교해 볼 수 있다.depths = [None, 1, 2, 3, 4]for depth in depths: gbr = GradientBoostingRegressor(max_depth=depth, n_estimators=300, random_state=2) gbr.fit(X_train, y_train) y_pred = gbr.predict(X_test) rmse = MSE(y_test, y_pred)**.5 print(f'max depth: {depth}, RMSE: {rmse}')max depth: None, RMSE: 869.2788645118395max depth: 1, RMSE: 707.8261886858736max depth: 2, RMSE: 653.7456840231495max depth: 3, RMSE: 646.4045923317708max depth: 4, RMSE: 663.048387855927max_depth=3일 때 최상의 결과를 낸다.3.3 Subsamplesubsample 매개변수는 기본 학습기에 사용될 샘플의 비율을 지정한다. subsample을 기본값인 1.0보다 작게 설정하면 트리를 훈련할 때 샘플의 일부만 사용하게 된다. 예를 들어 subsample=0.8인 경우 80%의 훈련 세트만 사용하여 각 트리를 훈련한다.max_depth=3으로 지정하고 subsample에 따라 점수 변화를 확인해보자.samples = [1, .9, .8, .7, .6, .5]for sample in samples: gbr = GradientBoostingRegressor(max_depth=3, n_estimators=300, subsample=sample, random_state=2) gbr.fit(X_train, y_train) y_pred = gbr.predict(X_test) rmse = MSE(y_test, y_pred)**.5 print(f'subsample: {sample}, RMSE: {rmse}')subsample: 1, RMSE: 646.4045923317708subsample: 0.9, RMSE: 620.1819001443569subsample: 0.8, RMSE: 617.2355650565677subsample: 0.7, RMSE: 612.9879156983139subsample: 0.6, RMSE: 622.6385116402317subsample: 0.5, RMSE: 626.9974073227554300개 트리, 최대깊이 3일 때 subsample=.7에서 가장 좋은 점수를 냈다.subsample이 1보다 작을 때 이런 모델을확률적 그레디언트 부스팅이라고 부른다. 확률적이라는 말은 모델에 무작위성이 주입된다는 말이다.3.4 RandomizedSearchCV잘 동작하는 모델을 얻었지만 그리드 서치를 수행하지 않았다. 앞선 모델을 참고했을 때 max_depth=3, subsample=.7, n_estimators=300, learning_rate=.1 근처가 그리드 서치로 탐색하기 좋은 출발점이다. n_estimators는 높이고 learning_rate는 낮추는 것이 좋을 것 같다.params = { 'subsample': [.65, .7, .75], 'n_estimators': [300, 500, 1000], 'learning_rate': [.05, .075, .1]}from sklearn.model_selection import RandomizedSearchCVgbr = GradientBoostingRegressor(max_depth=3, random_state=2)rand_reg = RandomizedSearchCV(gbr, params, n_iter=10, scoring='neg_mean_squared_error', cv=5, n_jobs=-1, random_state=2)rand_reg.fit(X_train, y_train)best_model = rand_reg.best_estimator_best_params = rand_reg.best_params_print(f'best params: {best_params}')best_score = np.sqrt(-rand_reg.best_score_)print(f'train score: {best_score:.3f}')y_pred = best_model.predict(X_test)rmse_test = MSE(y_test, y_pred)**.5print(f'test score: {rmse_test:.3f}')best params: {‘subsample’: 0.65, ‘n_estimators’: 300, ‘learning_rate’: 0.05}train score: 636.200test score: 625.985이 매개변수에서 한개 씩 혹은 여러 개를 바꿔서 실험해볼 수 있다. n_estimators=300이 최상의 모델이지만 learning_rate를 조정하고 n_estimators를 증가시켜 더 좋은 결과를 얻을 수 있다. subsamples도 실험해볼 수 있다.몇 번의 실험을 반복한 후에 다음 결과를 얻었다.gbr = GradientBoostingRegressor(max_depth=3, n_estimators=1600, subsample=.75, learning_rate=.02, random_state=2)gbr.fit(X_train, y_train)y_pred = gbr.predict(X_test)rmse = MSE(y_test, y_pred)**.5print(f'RMSE: {rmse}')RMSE: 596.9544588974487n_estimators를 1600으로 크게 늘리고, learning_rate를 .02로 줄였다. 그 다음 이전과 비슷한 subsample=.75와 max_depth=3으로 하여 597의 RMSE를 얻었다.이제 XGBoost가 위에 언급했던 매개변수에서 그레디언트 부스팅과 어떻게 다른지 확인해보자.3.5 XGBoostXGBoost의 일반적인 구조는 동일한 그레디언트 부스팅의 고급버전이다. 즉 잔차로부터 훈련한 트리를 추가하여 약한 학습기를 강력한 학습기로 바꾼다.이전에 소개한 매개변수와 다른 것은 learning_rate으로 XGBoost에서는 eta이다.동일한 매개변수로 XGBoost 회귀 모델을 만들어보고 결과를 비교해보자.다음처럼 xgboost 패키지에서 XGBRegressor를 임포트하고, 모델을 초기화하고 훈련한 다음 점수를 계산한다.from xgboost import XGBRegressorxg_reg = XGBRegressor(max_depth=3, n_estimators=1600, subsample=.75, eta=.02, random_state=2)xg_reg.fit(X_train, y_train)y_pred = xg_reg.predict(X_test)print(MSE(y_test, y_pred)**.5)584.3395337495713점수가 더 좋다. 더 좋은 점수가 나온 이유는 다음에 자세히 알아볼 것이다.머신러닝 모델을 만들 때 성능과 속도는 가장 중요한 두가지 요소이다. XGBoost가 매우 성능이 높다는 것을 여러 번 보았다. XGBoost가 일반적으로 그레디언트 부스팅보다 선호되는 이유는 더 좋은 성능을 내고 더 빠르기 때문이다." }, { "title": "2 그레디언트 부스팅 구현", "url": "/posts/make-gbmodel/", "categories": "XGB FOR GRADIENT BOOSTING, GRADIENT BOOSTING", "tags": "gradient boosting", "date": "2022-06-02 19:01:00 +0900", "snippet": "그레디언트 부스팅의 작동 방식을 살펴보고 이전 트리의 오차에 새로운 트리를 훈련하는 식으로 그레디언트 부스팅 모델을 만들어본다. 여기서 수학적인 핵심 요소는 잔차(residual)이다. 그 다음 사이킷-런의 그레디언트 부스팅 모델을 사용해 동일한 결과를 구해볼 것이다.2.1 잔차 (Residual)잔차는 타깃과 모델의 예측 사이의 차이이다. 통계에서는 일반적으로 선형 회귀 모델이 데이터에 얼마나 잘맞는지 평가하기 위해 잔차를 사용한다.다음과 같은 예를 생각하자. 자전거 대여 예측: 759 타깃: 799 잔차: 799 - 759 = 40 소득 예측: 100,000 타깃: 88,000 잔차: 88,000 - 100,000 = -12,000 여기서 보듯이 잔차는 모델 예측이 정답에서 얼마나 떨어져 있는지 알려주며 양수 또는 음수일 수 있다.다음은 선형 회귀 모델의 잔차를 알려주는 그림이다.선형 회귀의 목적은 잔차의 제곱을 최소화하는 것이다. 그림에 나와 있듯이 잔차는 선형 회귀 직선이 데이터에 얼마나 잘 맞는지 보여준다. 통계학에서 종종 데이터에 대한 통찰을 얻기 위해 잔차를 그래프로 시각화하여 선형 회귀 분석을 수행한다.그레디언트 부스팅 알고리즘을 직접 구현해보기 위해 각 트리의 잔차를 계산하고 이 잔차에 새로운 모델을 훈련해보자.2.2 그레디언트 부스팅 모델 구현모델을 직접 구현해보면 작동방식을 잘 이해할 수 있을 것이다. 모델을 만들기 전에 데이터를 준비하고 모델에 주입할 수 있도록 전처리 해준다.자전거 대여 데이터셋 로드import pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')import xgboost as xgbxgb.set_config(verbosity=0) # 로그 제거df_bikes = pd.read_csv('./bike_rentals_cleaned.csv')X_bikes = df_bikes.iloc[:, :-1]y_bikes = df_bikes.iloc[:, -1]from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X_bikes, y_bikes, random_state=2)그레디언트 부스팅 모델 구현1. 결정 트리 훈련max_depth=1인 결정트리 스텀프를 사용하거나 max_depth=2 or 3인 결정트리를 사용할 수 있다. 기본학습기라 부르는 결정트리는 높은 정확도를 위해 튜닝하지 않는다. 기본 학습기에 크게 의존하는 모델이 아니라 오차에서 학습하는 모델을 원하기 때문이다. 앙상블의 첫번째인 tree_1을 max_depth=2로 결정트리를 초기화하고 훈련 세트에서 훈련한다.from sklearn.tree import DecisionTreeRegressorimport matplotlib.pyplot as pltfrom sklearn.tree import plot_treetree_1 = DecisionTreeRegressor(max_depth=2, random_state=2)tree_1.fit(X_train, y_train)# 기본학습기 플로팅plt.figure(figsize=(13, 8))plot_tree(tree_1, feature_names=list(X_train.columns), filled=True, rounded=True, fontsize=10)plt.show()2. 훈련 세트에 대한 예측테스트 세트가 아니라 훈련 세트에 대한 예측을 만든다. 잔차를 계산하기 위해서 훈련 단계에서 예측과 타깃을 비교해야 하기 때문이다. 모델의 테스트 단계는 모든 트리를 구성한 후 마지막에 온다. tree_1의 predict() 메소드에 X_train을 입력하여 첫 번째 반복에 대한 훈련 세트 예측을 만든다.y_train_pred = tree_1.predict(X_train)3. 잔차 계산예측과 타깃사이의 차이를 구한다.# 잔차는 다음 트리의 타깃이 되기 때문에 y2_train이라고 명명함y2_train = y_train - y_train_pred4. 새로운 트리 훈련새로운 트리는 이 잔차를 맞추는 것을 목적으로 훈련한다.잔차에서 트리를 훈련하는 것은 훈련 세트에서 훈련하는 것과 다르다. 주요한 차이는 예측값이다. 자전거 대여 데이터셋에서 잔차에 새로운 트리를 훈련할 때 점점 더 작은 값을 얻을 것이다. 새로운 트리를 초기화하고 X_train과 잔차인 y2_train에서 훈련한다.tree_2 = DecisionTreeRegressor(max_depth=2, random_state=2)tree_2.fit(X_train, y2_train)5. 2~4 단계 반복이 과정이 지속되면 잔차는 양수나 음수 방향으로 0에 가까워 진다. 양상블에 추가할 트리 개수 만큼 반복이 계속된다. 세번째 트리에서 이 과정을 반복해 볼 것이다.y2_train_pred = tree_2.predict(X_train)y3_train = y2_train - y2_train_predtree_3 = DecisionTreeRegressor(max_depth=2, random_state=2)tree_3.fit(X_train, y3_train)이 과정이 수십, 수백, 수천개의 트리까지 계속될 수 있다. 일반적인 상황이라면 계속 진행할 것이다. 약한 학습기를 강력한 학습기로 만드려면 몇 개 트리로는 부족하다. 여기서 목적은 그레디언트 부스팅의 작동방식을 이해하는 것이기 때무에 일반적인 개념을 다룬 것에 만족하고 다음으로 넘어가자.6. 결과 더하기다음 처럼 최종 결과를 위해 테스트 세트에 대한 각 예측을 만든다.y1_pred = tree_1.predict(X_test)y2_pred = tree_2.predict(X_test)y3_pred = tree_3.predict(X_test)각 예측의 잔차는 양수와 음수가 뒤섞여 있기 때문에 이 예측을 모두 더하면 타깃에 가까운 결과를 만들어 낼 수 있다.\\[R_i = R_{i+1}+y_{i+1}, \\quad where \\quadR_0=y_{true}\\]7. 평가마지막으로 다음처럼 평균 제곱근 오차 (MSE)를 계산한다.from sklearn.metrics import mean_squared_error as MSEMSE(y_test, y_pred)**.5911.0479538776444강력하지 않은 약한 학습기를 사용한 것 치곤 나쁘지 않다. 이제 사이킷-런을 사용해 동일한 결과를 만들어보자.2.3 사이킷런의 그레디언트 부스팅 모델사이킷런의 GradientBoostingRegressor를 사용해 이전과 동일한 결과를 얻을 수 있는 지 확인해보자. 이를 위해 몇 개의 매개변수를 조정할 것이다. GradientBoostingRegressor를 사용하면 그레디언트 부스팅 알고리즘을 훨씬 쉽고 빠르게 구현할 수 있다.from sklearn.ensemble import GradientBoostingRegressorgbr = GradientBoostingRegressor(max_depth=2, n_estimators=3, random_state=2, learning_rate=1.0)gbr.fit(X_train, y_train)y_pred = gbr.predict(X_test)MSE(y_test, y_pred)**.5911.0479538776439이 결과는 소수점 11자리까지 모두 같다! 이제 반복횟수를 점점 늘려볼 것이다.gbr = GradientBoostingRegressor(max_depth=2, n_estimators=30, random_state=2, learning_rate=1.0)gbr.fit(X_train, y_train)y_pred = gbr.predict(X_test)MSE(y_test, y_pred)**.5857.1072323426944점수가 향상되었다. 이번에는 300개로 늘려보자.gbr = GradientBoostingRegressor(max_depth=2, n_estimators=300, random_state=2, learning_rate=1.0)gbr.fit(X_train, y_train)y_pred = gbr.predict(X_test)print(MSE(y_test, y_pred)**.5)936.3617413678853오잉? 점수가 나빠졌다. learning_rate을 제거하고 기본값을 사용해보자.gbr = GradientBoostingRegressor(max_depth=2, n_estimators=300, random_state=2)gbr.fit(X_train, y_train)y_pred = gbr.predict(X_test)print(MSE(y_test, y_pred)**.5)653.7456840231495오… 사이킷-런의 learning_rate기본값을 사용해 점수를 936에서 654로 낮추었다.다음에는 learning_rate 매개변수에 초점을 맞추면서 그레디언트 부스팅의 다른 매개변수에 대해 알아보도록 하자." }, { "title": "1 배깅에서 부스팅까지", "url": "/posts/bagtoboost/", "categories": "XGB FOR GRADIENT BOOSTING, GRADIENT BOOSTING", "tags": "gradient boosting, bagging", "date": "2022-06-02 19:00:00 +0900", "snippet": "랜덤 포레스트 같은 앙상블 머신러닝 알고리즘이 많은 모델을 하나로 연결하여 더 나은 예측을 만드는 이유를 알고있다.랜덤 포레스트는 (결정 트리에서)부트 스트랩 샘플을 사용하기 때문에배깅알고리즘으로 분류된다.이와 달리부스팅은 개별 트리의 실수로부터 학습한다.이전 트리의 오차를 기반으로 새로운 트리를 훈련하는 것이 기본적인 아이디어이다.부스팅에서 기존 트리에 대한 오차를 수정하는 것은 배깅과 다른 접근 방법이다.배깅 모델에서는 새로운 트리가 이전 트리에 관심을 주지 않는다.또한 새로운 트리는 부트스트랩 샘플링을 사용해 처음부터 훈련되며 최종 모델은 모든 개별 트리의 결과를 합친 것이다.하지만 부스팅에서는 개별 트리가 이전 트리를 기반으로 만들어진다.독립적으로 트리가 동작하지 않으며 다른 트리 위에 만들어진다.1.1 에이다 부스트에이다 부스트는 인기 있는 초기 부스팅 모델 중 하나이다.에이다 부스트에서는 새로운 트리가 이전 트리의 오차를 기반으로 가중치를 조정한다.오류 샘플의 가중치를 높여 잘못된 예측에 더 많은 주의를 기울인다.에이다 부스트는 이렇게 실수에서 학습하기 때문에 약한 학습기를 강력한 학습기로 만들 수 있다.약한 학습기는 우연보다 조금 나은 성능을 내는 머신러닝 모델을 말한다.강한 학습기는 많은 양의 데이터에서 학습하여 매우 잘 수행되는 모델이다.약한 학습기를 강력한 학습기로 변환하는 것이 부스팅 알고리즘의 일반적인 아이디어이다.약한 학습기는 무작위 예측보다 조금 낫다.하지만 약한 학습기로 시작하는 데는 목적이 있다.일반적으로 부스팅은 강력한 기반 모델을 만드는 것이 아니라 반복적으로 오류를 고치는 데 초점을 둔다.기반 모델이 너무 강력하면 학습 과정이 제한되어 부스팅 모델의 전략을 약화시킨다.수백번의 반복을 통해 약한 학습기가 강력한 학습기로 바뀐다.즉, 작은 성능 개선을 오래 지속한다.부스팅은 지난 수십년 동안 최적의 결과를 만드는 점에서 가장 뛰어난 머신러닝 전략 중 하나이다.에이다 부스트에 대한 자세한 설명은 생략한다.이제 성능면에서 약간 더 뛰어난 에이다 부스트의 강력한 대안인 그레디언트 부스팅을 알아보자.1.2 그레디언트 부스팅 (gradient boosting) 의 특징그레디언트 부스팅은 에이다 부스트와는 다른 전략을 사용한다.그레디언트 부스팅도 잘못된 예측을 기반으로 조정되지만 한 단계 더 나아간다.그레디언트 부스팅은 이전 트리의 예측 오차를 기반으로 완전히 새로운 트리를 훈련한다.즉, 그레디언트 부스팅은 각 트리의 실수를 살펴보고 이런 실수에 대한 완전한 새로운 트리를 만든다.새로운 트리는 이전 트리에서 올바르게 예측된 값에는 영향을 받지 않는다.오차에만 초점을 맞추는 머신러닝 알고리즘을 만드려면 정확한 최종 예측을 만들기 위해 오차를 계산하는 방벙이 필요하다.이런 방법은 모델의 예측과 실제 값 사이의 차이인잔차 (residual)를 활용한다.일반적인 방법은 다음과 같다.그레디언트 부스팅은 각 트리 예측값을 더해 모델 평가에 사용한다.이 아이디어는 그레디언트 부스팅의 고급 버전인 XGBoost의 핵심이므로 트리의 예측을 계산하고 더하는 것을 이해하는 것이 중요하다.그레디언트 부스팅 모델을 직접 만들어 보면 예측을 계산하고 더하는 과정을 잘 볼 수 있다.다음 절에서 직접 그레디언트 부스팅 모델을 만들어 볼 것이다.먼저 그레디언트 부스팅의 작동 방식에 대해 배워보자." }, { "title": "4 랜덤 포레스트 성능 향상", "url": "/posts/rfperform/", "categories": "XGB FOR GRADIENT BOOSTING, RANDOM FOREST", "tags": "random forest", "date": "2022-06-02 06:02:00 +0900", "snippet": "지난번 랜덤 포레스트 회귀 모델로 자전거의 일별 대여량을 예측하여 RMSE 점수 945가 나왔었다. 이번에는 하이퍼 파라미터 튜닝을 통하여 가능한 더 낮은 점수를 얻어볼 것이다.4.1 데이터 셋 준비from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X_bikes, y_bikes, random_state=2)4.2 n_estimators합리적인 n_estimators 값을 선택해보자. n_estimator를 증가시키면 시간과 비용이 늘어나지만 정확도는 향상시킬 수 있다.from sklearn.metrics import mean_squared_errorrmse_scores = []estimators = []rf = RandomForestRegressor(warm_start=True, n_jobs=-1, random_state=2)est = 10for i in range(21): rf.set_params(n_estimators=est) rf.fit(X_train, y_train) rmse = mean_squared_error(y_test, rf.predict(X_test), squared=False) rmse_scores.append(rmse) estimators.append(est) est += 25plt.figure(figsize=(15, 7))plt.plot(estimators, rmse_scores)plt.xlabel('Number of Trees')plt.ylabel('RMSE')plt.title('Random Forest Bike Rentals', fontsize=15)plt.show()50개 언저리에서 가장 좋은 성능을 발휘한다. 100개가 넘어가면 에러가 상승하기 시작한다. 나중에 다시 살펴본다.4.3 cross_val_score위 그래프를 보면 RMSE 범위가 620에서 690사이이다. cross_val_score() 함수로 이 데이터셋에 대해 교차검증을 해보자. 교차 검증 함수는 훈련된 모델을 반환하지 않기 때문에 oob_score_를 확인 할 수 없다.rf = RandomForestRegressor(n_estimators=50, warm_start=True, n_jobs=-1, random_state=2)scores = cross_val_score(rf, X_bikes, y_bikes, scoring='neg_mean_squared_error', cv=10)rmse = np.sqrt(-scores)print(f'RMSE:{np.round(rmse, 3)}')print(f'RMSE mean:{rmse.mean():.3f}')RMSE:[ 836.482 541.898 533.086 812.782 894.877 881.117 794.103 828.968772.517 2128.148]RMSE mean:902.398이 점수는 이전보다 더 좋다. 그러나 RMSE 마지막 폴드의 에러가 매우 높다. 이는 데이터에 있는 오류나 이상치(outline) 때문일 수 있다.4.4 하이퍼파라미터 튜닝이제 RandomizedSearchCV로 하이퍼파라미터 튜닝을 수행해보자.아래는 여러가지 하이퍼파라미터를 넣고 성능을 보기 위한 함수이다.from sklearn.model_selection import RandomizedSearchCVfrom sklearn.metrics import mean_squared_error as MSEdef randomized_search_reg(params, runs=16, reg=RandomForestRegressor(random_state=2,n_jobs=-1)): rand_reg = RandomizedSearchCV(reg, params, n_iter=runs, scoring='neg_mean_squared_error', cv=10, n_jobs=-1, random_state=2) rand_reg.fit(X_train, y_train) best_model = rand_reg.best_estimator_ best_params = rand_reg.best_params_ print(f'best parameters: {best_params}') best_score = np.sqrt(-rand_reg.best_score_) print(f'train score: {best_score}') y_pred = best_model.predict(X_test) rmse_test = MSE(y_test, y_pred)**.5 print(f'test score: {rmse_test:.3f}')1트초기 매개변수 그리드로 위 함수를 호출해 첫번쨰 결과를 확인한다%%timeparams = { 'min_weight_fraction_leaf': [0, .0025, .005, .00785, .01, .05], 'min_samples_split': [2, .01, .02, .03, .04, .06, .08, .1], 'min_samples_leaf': [1, 2, 4, 6, 8, 10, 20, 30], 'min_impurity_decrease': [0, .01, .05, .1, .15, .2], 'max_leaf_nodes': [10, 15, 20, 25, 30, 35, 40, 45, 50, None], 'max_features': ['auto', .8, .7, .6, .5, .4], 'max_depth': [None, 2, 4, 6, 8, 10, 20]}randomized_search_reg(params)best parameters: {‘min_weight_fraction_leaf’: 0, ‘min_samples_split’: 0.03, ‘min_samples_leaf’: 6, ‘min_impurity_decrease’: 0.05, ‘max_leaf_nodes’: 25, ‘max_features’: 0.7, ‘max_depth’: None}train score: 759.0756188493968test score: 701.802CPU times: user 1.1 s, sys: 68.4 ms, total: 1.17 sWall time: 10 s2트탐색범위를 좁혀본다%%timeparams = { 'min_samples_leaf': [1, 2, 4, 6, 8, 10, 20, 30], 'min_impurity_decrease': [0, .01, .05, .1, .15, .2], 'max_features': ['auto', .8, .7, .6, .5, .4], 'max_depth': [None, 2, 4, 6, 8, 10, 20]}randomized_search_reg(params)best parameters: {‘min_samples_leaf’: 1, ‘min_impurity_decrease’: 0.1, ‘max_features’: 0.6, ‘max_depth’: 10}train score: 679.0520498695299test score: 626.541CPU times: user 1.13 s, sys: 72.7 ms, total: 1.2 sWall time: 10.2 s3트탐색횟수를 늘리고 max_depth를 더 늘려본다%%timeparams = { 'min_samples_leaf': [1, 2, 4, 6, 8, 10, 20, 30], 'min_impurity_decrease': [0, .01, .05, .1, .15, .2], 'max_features': ['auto', .8, .7, .6, .5, .4], 'max_depth': [None, 4, 6, 8, 10, 12, 15, 20]}randomized_search_reg(params, runs=20)best parameters: {‘min_samples_leaf’: 1, ‘min_impurity_decrease’: 0.1, ‘max_features’: 0.6, ‘max_depth’: 12}train score: 675.1280049404816test score: 619.014CPU times: user 1.35 s, sys: 84.1 ms, total: 1.44 sWall time: 12.9 s4트:이전 결과를 바탕으로 범위를 더 좁혀본다%%timeparams = { 'min_samples_leaf': [1, 2, 3, 4, 5, 6], 'min_impurity_decrease': [0, .01, .05, .08, .1, .12, .15], 'max_features': ['auto', .8, .7, .6, .5, .4], 'max_depth': [None, 8, 10, 12, 14, 16, 18, 20]}randomized_search_reg(params)best parameters: {‘min_samples_leaf’: 1, ‘min_impurity_decrease’: 0.05, ‘max_features’: 0.7, ‘max_depth’: 18}train score: 679.5945071230298test score: 630.954CPU times: user 1.19 s, sys: 77.8 ms, total: 1.27 sWall time: 10.9 s에러가 늘어났으므로 여기서 멈추고, n_estimator나 더 늘려본다.5트: 데이터 이상으로 인한 저조한 성능n-estimators 늘려보기%%timeparams = { 'min_samples_leaf': [1, 2, 4, 6, 8, 10, 20, 30], 'min_impurity_decrease': [0, .01, .05, .1, .15, .2], 'max_features': ['auto', .8, .7, .6, .5, .4], 'max_depth': [None, 4, 6, 8, 10, 12, 15, 20], 'n_estimators': [100]}randomized_search_reg(params, runs=20)best parameters: {‘n_estimators’: 100, ‘min_samples_leaf’: 1, ‘min_impurity_decrease’: 0.1, ‘max_features’: 0.6, ‘max_depth’: 12}train score: 675.1280049404816test score: 619.014CPU times: user 1.34 s, sys: 113 ms, total: 1.45 sWall time: 13.1 s마지막으로 cross_val_score()로 결과를 확인해본다.rf = RandomForestRegressor(n_estimators=100, min_impurity_decrease=.1, max_features=.6, max_depth=12, n_jobs=-1, random_state=2)scores = cross_val_score(rf, X_bikes, y_bikes, scoring='neg_mean_squared_error', cv=10)rmse = np.sqrt(-scores)print(f'RMSE:{np.round(rmse, 3)}')print(f'RMSE mean:{rmse.mean():.3f}')RMSE:[ 818.354 514.173 547.392 814.059 769.54 730.025 831.376 794.634756.83 1595.237]RMSE mean:817.162오잉?!?!? 점수가 더 나빠졌다.cross_val_score()의 마지막 폴드의 점수가 다른 것보다 2배 가량 높기 때문에 마지막 폴드에 문제가 있다고 유추해볼 수 있다. 데이터를 다시 섞어서 시도해보자.from sklearn.utils import shuffledf_shuffle_bikes = shuffle(df_bikes, random_state=2)X_shuffle_bikes = df_shuffle_bikes.iloc[:, :-1]y_shuffle_bikes = df_shuffle_bikes.iloc[:, -1]rf = RandomForestRegressor(n_estimators=100, min_impurity_decrease=.1, max_features=.6, max_depth=12, n_jobs=-1, random_state=2)scores = cross_val_score(rf, X_shuffle_bikes, y_shuffle_bikes, scoring='neg_mean_squared_error', cv=10)rmse = np.sqrt(-scores)print(f'RMSE:{np.round(rmse, 3)}')print(f'RMSE mean:{rmse.mean():.3f}')RMSE:[630.093 686.673 468.159 526.676 593.033 724.575 774.402 672.63 760.253616.797]RMSE mean:645.329기대한 대로 점수가 훨씬 좋아졌음을 알 수 있다.4.5 랜덤 포레스트의 단점결국 랜덤 포레스트는 개별 트리에 제약이 있다. 모든 트리가 동일한 실수를 저지르면 랜덤 포레스트도 실수를 한다. 앞의 사례에서 데이터를 섞기 전에 이런 경우가 있음을 보았다. 개별 트리가 해결할 수 없는 데이터 내의 문제 때문에 랜덤 포레스트의 성능이 향상될 수 없었다.이럴 때 트리의 실수로부터 배워서 초반의 단점을 개선할 수 있는 앙상블 방법이 도움이 될 수 있다. 부스팅은 트리가 저지를 실수에서 배우도록 설계되었다." }, { "title": "3 랜덤 포레스트 하이퍼 파라미터", "url": "/posts/randomforesthyperparameter/", "categories": "XGB FOR GRADIENT BOOSTING, RANDOM FOREST", "tags": "random forest", "date": "2022-06-02 06:02:00 +0900", "snippet": "이미 단일 결정 트리의 매개변수를 알아보았기 때무에 랜덤 포레스트에서 다룰 매개변수는 아주 많지 않다.여기서는 랜덤 포레스트에 추가된 매개변수를 먼저 살펴보고 이전 장에서 보았던 매개변수를 그룹으로 묶어서 알아볼 것이다. 이러한 매개변수는 XGBoost에서도 많이 사용된다.3.1 oob_scoreOOB는 Out of bag의 줄임말이다.랜덤 포레스트는 중복을 허용한 샘플링인 배깅을 통해 결정 트리를 만들기 때문에, 모든 샘플 중에 일부 샘플은 선택되지 않고 남아 있게 된다.이런 샘플을 테스트 세트로 사용할 수 있다. oob_score=True로 설정하면 랜덤 포레스트 모델을 훈련한 후 각 트리에서 사용되지 않은 샘플을 사용해 개별 트리의 예측 점수를 누적하여 평균을 낸다.다른 말로 하면 oob_score 매개변수는 테스트 점수의 대안을 제시하는 것이다. 모델을 훈련한 후 OOB점수를 바로 출력할 수 있다.인구 조사 데이터셋에 oob_score 매개변수를 적용해보았다. oob_score 매개변수를 사용하여 모델을 테스트하였기 때문에 여기에서는 편의상 데이터를 훈련 세트와 데이터 세트로 나누지 않을 것이다.rf = RandomForestClassifier(oob_score=True, n_estimators=10, random_state=2, n_jobs=-1)rf.fit(X_census, y_census)print(rf.oob_score_)0.8343109855348423데이터 1을 사용하지 않은 DT = {DT1, DT3, DT6}데이터 1의 대한 각각의예측확률= {DT1: 0.7, DT3: 0.6, DT6: 0.5}랜덤 포레스트의 최종 에측확률: 0.6위 과정을 반복 ⇒ OOB Score!그러나 여기에서 처럼 랜덤 포레스트의 개별 트리 개수가 작을 경우 정확도를 높이기 위해 수집할 OOB 샘플의 개수가 충분하지 않다.더 많은 트리는 더 많은 샘플을 의미하고 종종 정확도를 높인다.3.2 n_estimators랜덤 포레스트는많은 트리를 앙상블 했을 때 강력한 성능을 발휘한다. 얼마나 많아야 할까? 사이킷-런==0.22부터 n_estimator의 기본값을 10에서 100으로 변경했다. 100개의 트리가 분산을 줄이고 좋은 성능을 내는 데 충분할 수 있지만 데이터셋이 크면 500개 이상의 트리가 필요할 수 있다.n_estimator=50으로 지정하고 OOB점수의 변화를 확인해보겠다.rf = RandomForestClassifier(oob_score=True, n_estimators=50, random_state=2, n_jobs=-1)rf.fit(X_census, y_census)print(rf.oob_score_)0.8518780135745216확실히 성능이 향상되었다. 그렇다면 100개는 어떨까?rf = RandomForestClassifier(oob_score=True, n_estimators=100, random_state=2, n_jobs=-1)rf.fit(X_census, y_census)print(rf.oob_score_)0.8551334418476091조금 향상되었다. n_estimator를 계속 증가시키면 OOB점수는 결국 일정한 수준을 유지할 것이다.3.3 warm_startwarm_start 매개변수는 랜덤 포레스트의 트리 개수(n_estimators)를 결정하는데 도움이 된다. warm_start=True로 설정하면 처음부터 시작하지 않고 트리를 앙상블에 추가할 수 있다. n_estimators를 100에서 200으로바꾸면 200개의 트리를 가진 랜덤 포레스트를 만드는데 2배 더 오래걸린다. warm_start=True로 지정하면 처음부터 200개의 트리를 다시 만들지 않고 이전 모델에 이어서 트리를 추가한다.warm_start 매개변수를 사용해 n_estimator에 따라 OOB 점수의 변화를 그래프로 그릴 수 있다.import matplotlib.pyplot as pltimport seaborn as snssns.set()oob_scores = []rf = RandomForestClassifier(n_estimators=50, warm_start=True, oob_score=True, n_jobs=-1, random_state=2)rf.fit(X_census, y_census)oob_scores.append(rf.oob_score_)est = 50estimators = [est]for i in range(9): est += 50 estimators.append(est) rf.set_params(n_estimators=est) rf.fit(X_census, y_census) oob_scores.append(rf.oob_score_)plt.figure(figsize=(15, 7))plt.plot(estimators, oob_scores)plt.xlabel('Number of Trees')plt.ylabel('oob_score_')plt.title('Random Forest Warm Start', fontsize=15)plt.show()트리 개수 300개에서 점수가 가장 높다. 300개 이상의 트리를 사용하는 것은 비용과 시간 낭비이며 얻을 수 있는 이득이 크지 않다.3.4 bootstrapbootstrap=False로 설정하면 부트스트래핑을 사용하지 않는다. 따라서 oob_score_ 또한 사용할 수 없다.과소적합이 일어나는 경우 적용해볼 수 있겠지만 쓸 일은 없을 듯 하다.3.5 verbose기본값은 0으로 높은 숫자를 주면 줄수록 출력이 많아진다. 한번 실험해보는 것을 추천3.6 결정 트리 매개변수트리 깊이 max_depth분할 max_features min_samples_split min_impurity_decrease리프 노드 min_samples_leaf min_weight_fraction_leaf" }, { "title": "2 랜덤 포레스트", "url": "/posts/randomforest/", "categories": "XGB FOR GRADIENT BOOSTING, RANDOM FOREST", "tags": "random forest", "date": "2022-06-02 06:01:00 +0900", "snippet": "랜덤 포레스트의 작동 방식을 잘 이해하기 위해 사이킷-런으로 직접 모델-링을 해볼것이다.2.1 랜덤 포레스트 분류 모델간단한 인구조사 데이터셋으로 연봉이 5만달러 이상인지 예측하는 랜덤 포레스트 분류기를 만들어 본다. cross_val_score() 함수를 통해 테스트 결과가 잘 일반화 되는 지 확인해 볼 것이다.import pandas as pdimport numpy as npfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.model_selection import cross_val_scoreimport warningswarnings.filterwarnings('ignore')# 간편하게 받을 수 있는 인구 조사 데이터df_census = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data', header=None)df_census.columns = ['age', 'workclass', 'fnlwgt', 'education', 'education-num', 'marital-status', 'occupation', 'relationship', 'race', 'sex', 'capital-gain', 'capital-loss', 'hours-per-week', 'native-country', 'income']df_census.drop(['education'], axis=1, inplace=True) # 일단 버려df_census = pd.get_dummies(df_census) # 원핫 인코딩df_census.drop(['income_ &lt;=50K'], axis=1, inplace=True) # 타깃이 쪼개졌으므로 하나 지워준다# feature와 target을 분리해줘야 한다X_census = df_census.iloc[:, :-1]y_census = df_census.iloc[:, -1]# 모델링rf = RandomForestClassifier(n_estimators=10, random_state=2, n_jobs=-1)scores = cross_val_score(rf, X_census, y_census, cv=5)print(f'accuracy:{np.round(scores, 3)}')print(f'accuracy mean:{scores.mean():.3f}')accuracy:[0.851 0.844 0.851 0.852 0.851]accuracy mean:0.850기본 랜덤 포레스트 분류기가 결정트리 모델 (81%)보다 인구조사 데이터셋에서 더 나은 점수를 만든다.성능이 향상된 것은 배깅 때문일 것이다. 이 랜덤 포레스트는 10개의 트리(n_estimators=10)를 사용하기 때문에 한 개가 아니라 10개의 결정 트리를 기반으로 예측을 만든다. 각 트리는 부트 스트래핑 샘플을 사용하므로 다양성이 높아지고 이를 집계하면 분산이 줄어든다.기본적으로 랜덤 포레스트 분류기는 노드를 분할 할 때feature개수의 제곱근을 사용한다. 예를 들어 100개의 특성이 있다면 랜덤 포레스트의 각 결정 트리는 10개의 특성만 사용한다. 따라서 중복 샘플을 가진 두 트리의 분할이 달라지기 때문에 매우 다른 예측을 만들 수 있다. 이것이 랜덤 포레스트가 분산을 줄이는 또 하나의 방법이다.2.2 랜덤 포레스트 회귀 모델랜덤 포레스트 회귀 모델은 분류 모델과 마찬가지로 부트스트랩 샘플을 사용하지만노드 분할에 feature 개수의 제곱근이 아니라feature 전체를 사용한다.최종 예측은 다수결 투표가 아니라 모든 트리의 예측을 평균하여 만든다.df_bikes = pd.read_csv('./bike_rentals_cleaned.csv')print(df_bikes.head())X_bikes = df_bikes.iloc[:, :-1]y_bikes = df_bikes.iloc[:, -1]# 모델링from sklearn.ensemble import RandomForestRegressorrf = RandomForestRegressor(n_estimators=10, random_state=2, n_jobs=-1)scores = cross_val_score(rf, X_bikes, y_bikes, scoring='neg_mean_squared_error', cv=10)rmse = np.sqrt(-scores)print(f'RMSE:{np.round(rmse, 3)}')print(f'RMSE mean:{rmse.mean():.3f}')RMSE:[ 801.486 579.987 551.347 846.698 895.05 1097.522 893.738 809.284833.488 2145.046]RMSE mean:945.365이 랜덤 포레스트 모델은 이전에 하이퍼 파라미터 튜닝을 해줬던 단일 결정 트리 모델 만큼은 아니지만 잘 수행된다. 이에 대한 이유는 자전거 대여 데이터셋을 통해 자세히 알아볼 것이다." }, { "title": "1 배깅 앙상블 (Baggin ensemble)", "url": "/posts/bagginensemble/", "categories": "XGB FOR GRADIENT BOOSTING, RANDOM FOREST", "tags": "random forest", "date": "2022-06-02 06:00:00 +0900", "snippet": "앙상블 모델이 개별 머신러닝 모델보다 뛰어난 이유를 알아본다. 또한 배깅이 뭔지 알아보자.둘 모두 랜덤포레스트의 핵심이올시다.1.1 앙상블 방법머신러닝에서 앙상블 방법은 개별 모델의 예측을 합치는 머신러닝 모델을 말한다.앙상블 방법이 여러 모델의 결과를 연결하기 때문에 오차를 줄이고 더 나은 성능을 내는 경향이 있다.어떤 집이 시장에 나온 첫 달만에 팔릴지 예측한다고 가정하자.여러 개의 머신러닝 모델을 실행하여 로지스틱 회귀는 80% 정확도,결정 트리는 75% 정확도,k-최근접 이웃(K-nearest neighbors)은 77% 정확도를 얻었다.가장 정확한 모델인 로지스틱 회귀를 최종 모델로 정할 수 있다.그러나 더 나은 방법은 각 모델의 예측을 합치는 것이다.분류기의 경우 앙상블하는 대표적인 방법은다수결 투표(majority vote)이다.세 모델 중 적어도 두개가 첫 번째 달에 집이 팔린다고 예측하면 최종 예측이 Yes 그렇지 않으면 No가 된다.전체적인 정확도는 앙상블 방법을 사용할 때 일반적으로 더 높다.앙상블에서는 예측이 틀릴려면 한 모델이 틀리는 것으로는 충분하지 않다.즉 다수의 분류기가 틀려야 한다.앙상블 방법은 크게 두 가지로 나뉜다.첫 번째는 사이킷런의 VotingClassfier 처럼 사용자가 선택한 여러 종류의 머신러닝 모델을 연결하는 방식이다.두 번쨰는 XGBoost나 랜덤 포레스트 처럼 같은 종류의 모델을 여러개 합치는 앙상블이다.랜덤 포레스트는 모든 앙상블 방법 중에서 가장 인기 있고 널리 사용되는 알고리즘이다.랜덤 포레스트의 개별 모델은 결정 트리이다.랜덤 포레스트는 최종 예측을 만들기 위해 수백 또는 수천 개의 결정 트리로 구성될 수 있다.랜덤 포레스트는 분류일 경우 다수결 투표를 사용하고회귀일 경우 모델의 예측을 평균하지만 개별 트리를 만들기 위해부트스트랩 애그리게이션(bootstrap aggregation)의 약자인배깅이란 특별한 방법을 사용한다.1.2 배깅 (Bagging)부트스트래핑(bootstraping)은 중복을 허용한 샘플링을 의미한다.2N개의 색 구슬이 들어 있는 가방이 있다.한 번에 하나씩 N개의 구슬을 선택하려고 한다.구슬을 선택할 때마다 이를 가방에 다시 넣는다.아주 운이 나쁘면 동일한 구슬을 10번 선택할 수도 있다.어떤 구슬은 한 번 선택하게 되고 어떤 구슬은 전혀 선택하지 않을 수도 있다.다음은 N개의 구슬을 선택하는 예시이다.위 그림에서 볼 수 있듯이 부트스트랩 샘플은 중복을 허용한 샘플링으로 만든다.즉, 같은 샘플을 한 부트스트랩 샘플에 여러번 넣을 수 있다는 소리이다.랜덤 포레스트는 부트스트래핑을 사용한다.개별 결정 트리를 만들 때 부트스트래핑을 수행한다.모든 결정 트리가 동일한 샘플로 만들어진다면 모두 비슷한 예측을 만들게 되고 앙상블한 결과도 개별 트리와 비슷해 질 것이다.랜덤 포레스트는원본 데이터셋과 같은 크기의 부트스트래핑 샘플을 사용해 각 트리를 만든다.수학적으로 계산하면 평균적으로 각 트리의 샘플은 전체 샘플의 2/3을 포함하며 1/3은 중복된 샘플이다.부트스트래핑 단계 후에 각 결정 트리는 자신만의 예측을 만든다.이 트리의 예측을 모아서 최종예측을 만든다. 분류일 경우 다수결 투표를 사용하고 회귀일 경우 평균을 낸다.요약하면 랜덤 포레스트는 부트스트래핑을 사용한 결정 트리의 예측을 합치는 것이다.이러한 앙상블 방법을 배깅이라고 한다." }, { "title": "5 심장 질환 예측하기", "url": "/posts/hd/", "categories": "XGB FOR GRADIENT BOOSTING, DECISION TREE", "tags": "decision tree, modeling", "date": "2022-06-01 17:30:00 +0900", "snippet": "머신러닝을 사용해 심장질환을 예측해달라는 병원의 요청을 받았다고 가정한다. 의사와 간화사가 환자의 건강을 돌보기 위해 관심을 두어야 할 중요한 두 세개의 feature를 예측하는 모델을 만드는 것이 목표이다.결정 트리 분류기를 사용하고 하이퍼 파라미터 튜닝을 해보자. 모델을 만든 후 심장 질환을 예측하는 데 가장 중요한 특성을 가진 feature_importance_ 를 사용해 결과를 해석할 것이다.5.1 심장 질환 데이터셋df_heart = pd.read_csv('./heart_disease.csv')df_heart.head()target=1은 심장 질환이 있는 것이고 0은 그렇지 안다는 것이다.다음은 각 feature의 의미이다. age: 나이 sex: 성별 cp: 가슴 통증(chest pain) (1=전형적인 협심증, 2=비전형적인 협심증, 3=협심증이 아닌 통증, 4=무증상) trestbps: 안정혈압 (입원시 mmHg) chol: 혈중 콜레스테롤(serum cholesterol) (mg/dl) fbs: 공복 혈당 &gt; 120 mg/dl ? 1 : 0 restecg: 심전도 결과 (0: 정상, 1: ST-T파 이상(T파 반전 및/또는 0.05 mV이상의 ST 상승 또는 감소), 2: Estes 기준에 의해 좌심실 비대증 가능성 또는 유력) thalach: 최대 심장 박동 수 exang: 운동으로 인한 협심증 (1: yes, 0: no) oldpeak: 휴식 대비 운동으로 인한 ST감소 slope: 최대 운동 ST 세그먼트 기울기 (1: 상승 기울기, 2: 수평, 3: 하강 기울기) ca: 형광 투시로 착색된 주요 혈관 수 (0 ~ 3) thal: 탈륨 스트레스 테스트, (3: 정상, 6: 고정 결함, 7: 가역적 결함)머신러닝 작업을 위해 훈련 세트와 테스트 세트로 나눈다.X = df_heart.iloc[:, :-1]y = df_heart.iloc[:, -1]X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=2)5.2 결정 트리 분류기하이퍼 파라미터 튜닝 하기 전에 비교를 위해 기준이 될만한 모델을 만든다.다음처럼 DecisionTreeClassfier 클래스와 cross_val_score() 함수를 사용한다.model = DecisionTreeClassifier(random_state=2)scores = cross_val_score(model, X, y, cv=5)print(f'\\n... accuracy:{np.round(scores, 2)} ...\\n')print(f'\\n... accuracy mean:{scores.mean():.2f} ...\\n') … accuracy:[0.75 0.85 0.75 0.7 0.72] … … accuracy mean:0.76 …초기 모델의 정확도는 76%이다. 하이퍼 파라미터 튜닝으로 더 나은 성능을 얻을 수 있을 지 확인해보자.RandomizedSearchedCV탐색할 하이퍼 파라미터가 많을 때 GridSearchCV로 하이퍼 파라미터 튜닝을 하면 너무 오랜 시간이 걸릴 수 있다. 이때 RandomziedSearchCV 는 GridSearchCV와 동일한 방식으로 동작하지만 모든 하이퍼파라미터 조합을 테스트하는 대신 랜덤한 조합을 테스트한다. 즉 모든 값을 테스트하지 않으며 제한된 시간 안에 최상의 조합을 찾는다.RandomizedSearchCV를 사용해서 점수를 출력하고 최상의 모델을 반환하는 함수를 만든다. 이 함수의 매개변수는 params, runs(시도할 조합의 횟수), DecisionTreeClassfier 객체이다.from sklearn.model_selection import RandomizedSearchCVdef randomized_search_clf(params, runs=20, clf=DecisionTreeClassifier( random_state=2)): rand_clf = RandomizedSearchCV(clf, params, n_iter=runs, cv=5, n_jobs=-1, random_state=2) rand_clf.fit(X_train, y_train) best_model = rand_clf.best_estimator_ best_score = rand_clf.best_score_ print(f'\\n... train score: {best_score:.3f} ...\\n') y_pred = rand_clf.best_estimator_.predict(X_test) accuracy = accuracy_score(y_test, y_pred) print(f'\\n... test score: {accuracy:.3f} ...\\n') return best_model5.3 하이퍼 파라미터 튜닝하이퍼파라미터를 고르는 하나의 완벽한 방법은 존재하지 않는다. 다음은 randomized_search_clf() 함수에 넣은 초기 매개변수 리스트이다. 분산을 줄이고 넓은 범위를 탐색하기 위해 수치를 선택했다.%%timeparams = { 'criterion': ['entropy', 'gini'], 'splitter': ['random', 'best'], 'min_samples_split': [2, 3, 4, 5, 6, 8, 10], 'min_samples_leaf': [1, .01, .02, .03, .04], 'min_impurity_decrease': [0, .0005, .005, .05, .1, .15, .2], 'max_leaf_nodes': [10, 15, 20, 25, 30, 35, 40, 45, 50, None], 'max_features': ['auto', .95, .9, .85, .8, .75, .7], 'max_depth': [None, 2, 4, 6, 8], 'min_weight_fraction_leaf': [0, .0025, .005, .0075, .01, .05]}randomized_search_clf(params) … train score: 0.798 … … test score: 0.855 … … DecisionTreeClassifier(criterion=’entropy’, max_depth=8, max_features=0.8, max_leaf_nodes=45, min_impurity_decrease=0, min_samples_leaf=0.04, min_samples_split=10, min_weight_fraction_leaf=0.05, random_state=2) … CPU times: user 211 ms, sys: 5.54 ms, total: 217 ms Wall time: 749 msCPU times: user 211 ms, sys: 5.54 ms, total: 217 msWall time: 749 ms확실히 향상되었고 테스트 세트에 잘 일반화 되었다. 범위를 좁혀서 더 나은 결과를 얻을 수 있는지 알아보자.5.4 탐색 범위 좁히기매개변수 범위를 좁히는 것이 성능을 향상시킬 수 있는 한 가지 방법이다.예를 들어 최상의 모델에서 얻은 max_depth=8을 기준으로 탐색 범위를 7~9로 좁힐 수 있다.또 다른 전략은 기본값이 잘 동하는 매개변수를 탐색에서 제외시키는 것이다. 예를 들어 ‘entropy’는 차이가 크지 않기 때문에 ‘gini’ 대신에 추천하지 않는다. min_impurity_decrease도 기본값 그대로 둘 수 있다.새로운 매개변수 범위에서 100번으로 탐색 횟수를 증가시켜보자.%%timeparams = { 'max_depth': [None, 6, 7], 'max_features': ['auto', .78], 'max_leaf_nodes': [45, None], 'min_samples_leaf': [1, .035, .04, .045, .05], 'min_samples_split': [2, 9, 10], 'min_weight_fraction_leaf': [0, .05, .06, .07]}model = randomized_search_clf(params, runs=100)print(f'\\n... {model} ...\\n') … train score: 0.802 … … test score: 0.868 … … DecisionTreeClassifier(max_depth=7, max_features=0.78, max_leaf_nodes=45, min_samples_leaf=0.045, min_samples_split=9, min_weight_fraction_leaf=0.06, random_state=2) … CPU times: user 713 ms, sys: 35.2 ms, total: 748 msWall time: 5.13 s이 모델의 훈련 점수와 테스트 점수는 더욱 높아졌다.반환된 최상의 모델을 전체 데이터 셋에서 교차 검증 함수를 적용해 기본 모델과 비교해본다.scores = cross_val_score(best_model, X, y, cv=5)print(f'\\n... accuracy:{np.round(scores, 2)} ...\\n')print(f'\\n... accuracy mean:{scores.mean():.2f} ...\\n') … accuracy:[0.82 0.9 0.8 0.8 0.78] … … accuracy mean:0.82 …무려 6% 이득!5.5 특성 중요도 (feature importance)마지막으로 이 모델에서 가장 중요한 feature를 확인해보자. 결정 트리는 이런 값을 제공해주는 feature_importances_ 속성을 제공한다.먼저 앞서 만든 모델을 전체 데이터셋에서 훈련하자.모델을 훈련할 때 훈련세트와 테스트 세트를 섞지 않는 것이 중요하다. 하지만 최종 모델을 선택한 후에는 전체 데이터셋을 사용해 모델을 훈련하는 것이 정확도를 더 높일 수 있기 때문에 도움이 된다.best_model.fit(X, y)best_model.feature_importances_ array([0.04826754, 0.04081653, 0.48409586, 0.00568635, 0. , 0. , 0. , 0.00859483, 0. , 0.02690379, 0. , 0.18069065, 0.20494446])결과를 해석하기 난해하다. feature 이름과 feature importances를 딕셔너리로 만든 다음 특성 중요도의 내림차순으로 정렬해서 보자.feature_dict = dict(zip(X.columns, best_model.feature_importances_))import operatorsorted(feature_dict.items(), key=operator.itemgetter(1), reverse=True)[0:3] [(‘cp’, 0.4840958610240171), (‘thal’, 0.20494445570568706), (‘ca’, 0.18069065321397942)]이 값 들은 노드 분할에 사용된 feature별 감소된 불순도 량을 더한 후 전체 값이 1이 되도록 정규화한 것이다.가장 중요한 세 개의 특성은 다음과 같다. cp: 가슴 통증(chest pain) (1=전형적인 협심증, 2=비전형적인 협심증, 3=협심증이 아닌 통증, 4=무증상) thalach: 최대 심장 박동 수 ca: 형광 투시로 착색된 주요 혈관 수 (0 ~ 3)이제 가장 중요한 세 개의 특성인 가슴통증, 최대 심장 박동수, 형광 투시로 착색된 주요 혈관 수로 환자가 심장 질환을 가졌는지 82% 정확도로 예측할 수 있다고 의사와 간호사에게 말 할 수 있다." }, { "title": "4 결정 트리 하이퍼파라미터 튜닝", "url": "/posts/dthpt/", "categories": "XGB FOR GRADIENT BOOSTING, DECISION TREE", "tags": "decision tree", "date": "2022-06-01 17:15:00 +0900", "snippet": "하이퍼 파라미터는 파라미터와 다른것이다.머신러닝에서 파라미터는 모델이 튜닝될 때 조정된다. 예를 들어 선형회귀와 로지스틱 회귀의 가중치가 오차를 최소화하는 단계에서 조정되는 파라미터이다. 이와 다르게 하이퍼파라미터는 훈련 단계 이전에 미리 선택된다. 하이퍼 파라미터를 선택하지 않으면 기본값이 사용된다.4.1 결정 트리 회귀 모델하이퍼 파라미터는 실제로 여러가지 때려박아보는게 답이다. 다양한 하이퍼 파라미터 선택에 관한 이론들이 있지만 실전이 이론보다 앞선다고 한다. 데이터 셋마다 성능을 높일 수 있는 하이퍼파라미터 값이 다른다.하이퍼 파라미터를 선택하기 전에 DecisionTreeRegressor 클래스와 cross_val_score() 함수로 기준 점수를 확인해본다.import pandas as pd# --------------preprocessing------------------df_bikes = pd.read_csv('./bike_rentals_cleaned.csv')X_bikes = df_bikes.iloc[:, :-1]y_bikes = df_bikes.iloc[:, -1]from sklearn.linear_model import LinearRegressionX_train, X_test, y_train, y_test = train_test_split(X_bikes, y_bikes, random_state=1117)# ------------linear regression model-------------from sklearn.tree import DecisionTreeRegressorfrom sklearn.model_selection import cross_val_scorereg = DecisionTreeRegressor(random_state=1117)scores = cross_val_score(reg, X_bikes, y_bikes, scoring='neg_mean_squared_error', cv=5)rmse = np.sqrt(-scores)print(f'\\n... RMSE 평균:{rmse.mean():.2f} ...\\n') … RMSE 평균:1248.51 …좋지 못한 1248.51의 RMSE가 나왔다.분산이 너무 높아 모델이 데이터에 과대적합된 것인가? 훈련 세트에 대한 결정 트리의 성능을 확인하여 위 질문에 답을 얻을 수 있다.reg = DecisionTreeRegressor()reg.fit(X_train, y_train)y_pred = reg.predict(X_train)from sklearn.metrics import mean_squared_errorreg_mse = mean_squared_error(y_train, y_pred)reg_rmse = np.sqrt(reg_mse)reg_mse 0.0RMSE가 0이면 100% 싹다 맞췄다는 얘기이다. 이 점수와 교차 검증 결과인 1248.51을 함께 생각하면 결정 트리가 과대 적합되어 분산이 크다는 것이 확실하다. 훈련 세트는 완벽하게 맞췄지만 테스트 세트에서는 큰 차이가 발생해버린 것이다.하이퍼 파라미터는 이런 상황을 바로 잡을 수 있다.4.2 하이퍼 파라미터max_depthmax_depth는 트리의 깊이를 정의한다. 깊이는 분할 횟수를 결정한다. max_depth의 기본값은 None으로 제한이 없다. 따라서 수백이나 수천번 분할이 일어날 수 있으며 과대적합을 만든다. max_depth를 작은 값으로 제한하면 분산이 줄어들고 모델이 새로운 데이터에 잘 일반화 된다.최선의 max_depth를 어떻게 선택할 수 있는가?GridSearchCVGridSearchCV는 교차 검증을 사용해 최선의 결과를 만드는 매개변수 조합을 찾는다.GridSearchCV 클래스는 사이킷런의 다른 머신러닝 알고리즘처럼 동작한다. 즉 훈련 세트에서 훈련하고 테스트 세트에서 점수를 계산한다. 다른 모델과 주요한 차이점은 GridSearchCV가 최종모델을 선택하기 전에 모든 매개변수를 검사한다는 점이다.GridSearchCV의 핵심은 매개변수 값의 딕셔너리를 정의한다는 것이다. 올바른 조합이란 것은 없다. 한 가지 방법은 가장 작은 값과 갖아 큰 값 사이에서 일정 간격을 선택하는 것이다. 과대적합을 줄여야 하기 때문에 max_depth값을 줄여서 시도해보는 것이 좋다.GridSearchCV를 임포트하고 max_depth 파라미터의 리스트를 다음처럼 정의한다.from sklearn.model_selection import GridSearchCVparams = {'max_depth': [None, 2, 3, 4, 6, 8, 10, 20]} 일반적으로 max란 이름이 붙은 매개변수는 감소시키고 min이 붙은 매개변수는 증가시키면 분산이 줄어들고 과대적합이 방지된다그 다음 DecisionTreeRegressor 객체를 만들고 GridSearchCV에 params 딕셔너리와 평가지표를 함께 전달한다.reg = DecisionTreeRegressor(random_state=1117)grid_reg = GridSearchCV(reg, params, scoring='neg_mean_squared_error', cv=5, return_train_score=True,\t\t\t\t\t\t\t\t\t\t\t\tjobs=-1) # CPU 풀가동grid_reg.fit(X_train, y_train)데이터를 GridSearchCV에 fitting시켰으므로 이제 최상의 매개변수를 확인한다.best_params = grid_reg.best_params_print(f'\\n... best params : {best_params} ...\\n') … best params : {‘max_depth’: 8} …max_depth=8일 때 훈련 세트에서 최상의 교차 검증 점수를 만든다.훈련점수는 best_score_에 저장되어 있다.best_score = np.sqrt(-grid_reg.best_score_)print(f'\\n... train score : {best_score:.3f} ...\\n') … train score : 821.074 …테스트 점수는 다음과 같이 출력한다.best_model = grid_reg.best_estimator_y_pred = best_model.predict(X_test)from sklearn.metrics import mean_squared_errorrmse_test = mean_squared_error(y_test, y_pred)**.5print(f'\\n... test score : {rmse_test:.3f} ...\\n') … train score : 821.074 …1034로 확실히 분산이 줄어들었다.min_samples_leafmin_samples_leaf는 리프 노드가 가질 수 있는 최소 샘플의 개수를 제한한다. max_depth와 마찬가지로 min_samples_leaf는 과적합을 방지한다.min_samples_leaf의 기본값은 1로 제한이 없을 때 리프 노드는 하나의 샘플로 구성할 수 있다.(과적합되기 쉽다). min_samples_leaf를 증가시키면 분산을 줄일 수 있다. 예를 들어 min_samples_leaf=8 이면 모든 리프 노드는 최소한 8개 이상의 샘플을 담고 있어야 한다.min_samples_leaf의 값을 테스트하는 과정은 이전과 동일하다. 복붙을 하는 대신 DecisionTreeRegressor(random_state=1117)를 reg 객체에 할당하고 GridSearchCV르 사용해서 최상의 매개변수, 훈련 점수, 테스트 점수를 출력하는 함수를 작성하였다.def grid_search(params, reg=DecisionTreeRegressor(random_state=1117), X_train=X_train, X_test=X_test, y_train=y_train, y_test=y_test): grid_reg = GridSearchCV(reg, params, scoring='neg_mean_squared_error', cv=5, n_jobs=-1) grid_reg.fit(X_train, y_train) best_params = grid_reg.best_params_ best_score = np.sqrt(-grid_reg.best_score_) print(f'\\n... best params: {best_params} ...\\n') print(f'\\n... train score: {best_score:.3f} ...\\n') y_pred = grid_reg.best_estimator_.predict(X_test) rmse_test = mean_squared_error(y_test, y_pred)**.5 print(f'\\n... test score: {rmse_test:.3f} ...\\n')하이퍼 파라미터의 범위를 선택할 때 훈련 세트의 크기를 아는 것이 도움된다.X_train.shape … train score : 821.074 …훈련 세트가 548개 행을 가지고 있기 때문에 적절한 min_samples_leaf 값을 결정할 수 있다. grid_search의 입력으로 [1, 2, 4, 8, 20, 30]을 시도해본다.grid_search(params={'min_samples_leaf': [1, 2, 4, 6, 8, 10, 20, 30]}) … best params: {‘min_samples_leaf’: 2} … … train score: 855.425 … … test score: 898.941 …min_samples_leaf와 max_depth를 같이 넣어보자.grid_search(params={'max_depth': [None, 2, 3, 4, 6, 8, 10, 20], 'min_samples_leaf': [1, 2, 4, 6, 8, 10, 20, 30]}) … best params: {‘max_depth’: 8, ‘min_samples_leaf’: 1} … … train score: 821.074 … … test score: 1034.835 …어처구니가 없게도 훈련점수는 좋아졌지만 테스트점수는 나빠졌다(과적합).이전 예제에서 분산을 줄였던 것처럼 min_samples_leaf를 3보다 크게 설정해보자.grid_search(params={'max_depth': [None, 6, 7, 8, 9, 10], 'min_samples_leaf': [3, 5, 7, 9]}) … best params: {‘max_depth’: 8, ‘min_samples_leaf’: 5} … … train score: 849.492 … … test score: 793.616 …결과에서 볼 수 있듯이 테스트 점수가 향상되었다.max_leaf_nodesmax_leaf_nodes는 min_samples_leaf와 비슷하다. 리프 노드 하나당 샘플 개수의 하한을 지정하는 대신, 전체 트리의 리프 노드 개수의 상한을 지정한다. 예를 들어, max_leaf_nodes=10 으로 지정하면 트리 리프 노드가 최대 10개를 넘을 수 없다.max_featuresmax_features는 분산을 줄이는데 효과적인 매개변수이다. 분할마다 모든 feature를 고려하지 않고 매번 지정된 개수의 feature 중에서 선택한다.max_features의 옵션은 다음과 같다. None(default)와 ‘auto’는 전체 feature를 사용한다. ‘sqrt’는 전체 feature 개수의 제곱근을 사용한다. ‘log2’는 전체 log_2(feature 개수)를 사용한다. ex) 전체 feature 개수가 32개 ⇒ 분할 당 5개의 feature만 고려.min_samples_split분할을 제한하는 또 다른 방법은 min_samples_split이다. 이름에서 알 수 있듯이 1회 분할하기 위해 필요한 최소 sample 개수를 제한한다. 기본값은 2이다. 예를 들어, 이 값을 5로 설정하면 5개 보다 적은 노드는 더 이상 분할 하지 않는다.splittersplitter 매개 변수에는 ‘random’과 ‘best’ 두개의 옵션이 있다. 분할기는 노드를 분할하기 위한 feature 선택 방법이다. 기본값은 ‘best’로 정보이득(information gain)이 가장 큰 특성을 선택한다 (criterion으로 지정된 평가지표를 가장 줄이는 feature). 이와 달리 ‘random’은 랜덤하게 노드를 분할한다.splitter=’random’으로 하면 과대적합을 막고 다양한 트리를 만드는 효과가 있다.criterion결정 트리 회귀 모델과 분류 모델의 criterion값이 다르다. criterion은 분할 품질을 측정할 수 있는 방법을 제공한다. criterion에 지정한 함수를 가능한 분할마다 계산하여 비교한다. 가장 좋은 점수를 얻은 분할이 선택된다.회귀 모델일 경우 ‘squared_error’(평균 제곱 오차), ‘friedman_mse’(프리드만 MSE), ‘absolute error’, ‘poisson’(포이송 편차)가 있다. 기본값은 ‘squared_error’이다.분류 모델일 경우 앞서 언급한 ‘gini’(기본값)과 ‘entropy’가 있다. 일반적으로 두 옵션은 비슷한 결과를 만든다.min_impurity_decreasemin_impurity_decrease는 분할하기 위한 최소 불순도 감소를 지정한다.불순도는 각 노드의 예측이 얼마나 순수한지를 측정한다. 100%의 정확도를 가진 트리의 불순도는 0.0이다. 80% 정확도를 가진 트리의 평균적인 불순도는 0.20일 것이다.불순도는 결정 트리에서 중요한 개념이다. 트리를 성장시키는 과정에서 불순도는 지속적으로 감소되어야 한다. 각 노드에거 가장 크게 불순도를 감소시키는 분할이 선택된다.기본값은 0.0이다. 이 값을 증가시키면 임곗값에 도달할 때 트리의 성장이 멈춘다.min_weight_fraction_leafmin_weight_fraction_leaf는 리프 노드가 되기 위한 전체 가중치의 최소 비율이다. sample_weight를 지정해주지 않으면 샘플은 모두 동일한 가중치를 가진다.min_weight_fraction_leaf는 분산을 줄이고 과대적합을 막을 수 있는 또 다른 하이퍼파라미터이다. 기본값은 0.0이다. 500개의 샘플이 있고 가중치가 동일하다면, 이 매개변수를 0.01로 지정할 때 리프 노드가 되기 위한 최소 샘플 개수는 5개이다.cca_alphacca_alpha 매개변수는 트리를 만든 후 가지치기(prunning)를 하는 기능으로 여기서 설명하지는 않을 것이다. 자세한 내용은 최소 비용복잡도 가지치기 (minimal cost-complexity prunning)에 대해 알아볼 것.4.3 정리하이퍼 파라미터 튜닝을 할 때 몇 가지 고려사항이 있다. 소요 시간 하이퍼파라미터 개수 원하는 소수점 정확도소요 시간, 튜닝할 하이퍼 파라미터 개수, 원하는 정확도는 데이터셋과 프로젝트에 따라 다르다. 하이퍼파라미터는 서로 연관되어 있기 때문에 모두 수정할 필요는 없다. 작은 범위에서 튜닝하면 더 좋은 결과를 만들 수 있다." }, { "title": "3 분산(variance)과 편향(bias)", "url": "/posts/varbias/", "categories": "XGB FOR GRADIENT BOOSTING, DECISION TREE", "tags": "decision tree", "date": "2022-06-01 17:00:00 +0900", "snippet": "다음 그래프에 있는 데이터 포인트를 가지고 있다고 가정하자. 이 데이터에 직선 또는 곡선을 학습시켜 새로운 포인트에 대한 예측을 만들어야 한다. 랜덤한 포인트들의 그래프3.1 선형 회귀각 점들과 직선 사이의 거리 제곱을 최소화하는 선형회귀를 사용한다.직선은 일반적으로 편향이 크다. 머신러닝에서 편향은 모델을 실제 문제에 적용할 때 오차를 예측하는 데서 유래한다. 예측이 직선에 제한되어 있고 데이터 변화를 고려하지 못하기 때문에 편향이 크다고 할 수있다.많은 경우 직선은 정확한 예측을 하기에 충분히 복잡하지 않다. 이런 경우에 머신러닝 모델이 편향이 높고 데이터에 과소적합되었다고 말한다.3.2 8차 다항식다음과 같이 8차 다항식을 적용한다. 포인트가 9개이기 때문에 완벽하게 주어진 데이터에 적합시킬 수있다.이런 경우에 분산이 높다고 할 수 있겠다. 머신러닝에서 분산은 다른 훈련 데이터가 주어졌을 때 모델이 얼마나 변화하는지 나타내는 용어이다. 분산은 확률 변수와 평균 사이의 차이를 제곱한 것이다. 아홉 개의 새로운 데이터 포인트가 훈련 세트로 주어지면 위의 8차 다항식은 완전히 다른 모양으로 바뀔것이다. 따라서 분산이 높다.분산이 높은 모델은 데이터에 과대적합되기 쉽다. 이런 모델은 훈련 데이터에 너무 밀접하게 맞춰져 있기 때문에 새로운 데이터 포인트에 잘 일반화되지 못한다.3.3 3차 다항식마지막으로 3차 다항식을 적용해본다.이 3차 다항식은 분산과 편향 사이에 균형이 잘 잡혀있다. 일반적인 곡선의 형태를 따르면서 변동에 적응한다.분산과 편향의 균형낮은 분산은 훈련 세트가 달라져도 크게 다른 곡선을 만들지 않는다는 뜻이다. 낮은 편향은 이 모델을 실전에 적용했을 때 오차가 너무 크지 않다는 뜻이다. 머신러닝에서 낮은 분산과 편향을 가지는 것이 이상적이다.분산과 편향 사이에 균형을 잘 잡기 위한 가장 좋은 머신러닝 방법 중 하나는하이퍼파라미터 튜닝이다." }, { "title": "2 결정 트리 알고리즘", "url": "/posts/dtalg/", "categories": "XGB FOR GRADIENT BOOSTING, DECISION TREE", "tags": "decision tree", "date": "2022-06-01 16:45:00 +0900", "snippet": "결정 트리는 가지(branch)분할을 통해 데이터를 두 개의 노드로 나눈다. 가지 분할은 예측을 만드는 리프노드까지 계속된다. 실제 예를 다뤄보면 가지가 분할되는 방법과 리프 노드가 만들어지는 방법을 쉽게 이해할 수 있다. 더 자세한 내용을 살펴보기 전에 첫 번째 결정 트리 모델을 만들어 보자.2.1 첫 번째 결정 트리 모델인구 조사 데이터 셋을 통해 소득이 5만 달러 이상인지 예측하는 결정 트리를 만들어보자import pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')# 간편하게 받을 수 있는 인구 조사 데이터df_census = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data', header=None)df_census.columns = ['age', 'workclass', 'fnlwgt', 'education', 'education-num', 'marital-status', 'occupation', 'relationship', 'race', 'sex', 'capital-gain', 'capital-loss', 'hours-per-week', 'native-country', 'income']df_census.drop(['education'], axis=1, inplace=True) # 일단 버려df_census = pd.get_dummies(df_census) # 원핫 인코딩df_census.drop(['income_ &lt;=50K'], axis=1, inplace=True) # 타깃이 쪼개졌으므로 하나 지워준다# feature와 target을 분리해줘야 한다X = df_census.iloc[:, :-1]y = df_census.iloc[:, -1]train_test_split() 함수를 임포트하고 데이터를 훈련과 테스트 데이터 쌍으로 분리해준다. 할 때마다 결과가 달라지는 건 싫으니까 random_state도 아무거나 박아준다from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1117)그 다음 일반적인 단계에 따라 결정트리 분류기를 만들어준다. 여기서 accuracy_score() 는 정확하게 맞은 예측 횟수를 전체 예측 횟수로 나눈 값을 반환한다. 20개 예측 중에 19개가 맞았다면 accuracy_score() 함수는 95%를 반환한다from sklearn.tree import DecisionTreeClassifierfrom sklearn.metrics import accuracy_scoreclf = DecisionTreeClassifier(random_state=1117) # 1.모델 생성clf.fit(X_train, y_train) # 2.훈련y_pred = clf.predict(X_test) # 3.예측accuracy_score(y_pred, y_test) # 4. 평가2.2 결정 트리의 작동 원리결정트리의 내부 작동 방식은 그림으로 잘 나타낼 수 있다.import matplotlib.pyplot as pltfrom sklearn.tree import plot_treeplt.figure(figsize=(13, 8))plot_tree(clf, max_depth=2, # max_depth 설정 안 해주면 밑도 끝도 없이 그린다\t\t\t\t\tfeature_names=list(X.columns), class_names=['0', '1'], filled=True, rounded=True, fontsize=10)plt.show() 위에서 사용한 모델에서 맨위 2개층맨 위가 루트노드이다. 맨 위/ 맨 아래를 제외한 모든 사각형이 노드이다.지니 불순도 (gini impurity)노드의 두 번째 줄은 gini=x.xxx 이다. 이 값을 지니불순도라고 하며 결정 트리가 어떻게 분할할지 결정하는데 사용된다. 불순도 값이 가장 낮은 분할을 찾는 것이 목표이다. 지니 불순도가 0이면 하나의 클래스로만 이루어진 노드이다. 지니 불순도가 0이면 노드안 클래스별 샘플갯수가 동일한것이다. 0에 가까울 수록 좋다.지니 불순도를 계산하는 식은 다음과 같다.\\[gini=\\sum_{i=1}^c(p_i)^2\\]여기서 $p_i$는 전체 샘플 중에서 해당 클래스 샘플의 비율이고, $c$는 총 클래스 가짓수이다. 이 예시에서 $c=2$.스텀프 (stump)딱 한번만 분할된 트리를 스텀프라고 한다. 스텀프 자체는 강력한 모델이 아니지만 부스터로 사용되면 강력해질 수 있다." }, { "title": "1 결정 트리 개요", "url": "/posts/dtoverview/", "categories": "XGB FOR GRADIENT BOOSTING, DECISION TREE", "tags": "decision tree", "date": "2022-06-01 16:30:00 +0900", "snippet": "앙상블 방법 중 하나인 XGBoost의기본학습기(base learner)로 가장 널리 사용되는 결정 트리는 독특한 특징을 가진 머신러닝 알고리즘이다.선형 회귀와 로지스틱 회귀 처럼 특성을 가중치와 곱하는 대신 결정 트리는 특성에 대한 질문에 따라 데이터를 나눈다.사실 결정 트리를 만드는 것은스무고개게임을 하는 것과 같다.예를 들어, 결정 트리가 온도 특성을 가지고 데이터를 두 그룹으로 나눌 수 있다.온도가 70도 이상인 그룹과 70도 이하인 그룹이다.그 다음에는 각 그룹을 계절을 기반으로 나눌 수 있다.여름인 경우와 그렇지 않은 경우이다.이제 데이터는 네 개의 그룹으로 나뉘었다.알고리즘이 일정 수준의 정확도에 도달할 때까지 이렇게 데이터를 새로운 그룹으로 나누는 과정이 계속된다.결정 트리는 훈련세트에 있는 각 샘플을 정확한 타깃에 매핑할 때까지 수천 개의 그룹을 만들 수 있다.훈련세트에 대해서는 100% 정확도를 달성한다는 의미이다.하지만 이런 모델은 새로운 데이터에 잘 일반화되지 못한다.결정 트리는과대적합되기 쉽다.다른 말로 하면 결정트리는 훈련 데이터에만 너무 잘 맞을 수 있다.나중에 분산과 편향을 다룰 때 살펴볼 것이다.하이퍼 파라미터 튜닝은 과대적합을 막는 한가지 방법이다.또 다른 방법은랜덤 포레스트와 XGBoost가 사용하는 전략으로 많은 트리의 예측을 모으는 것이다." } ]
